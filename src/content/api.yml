title: API
body:
  - h1: API
  - p: >
      The API can be accessed in one of three ways: on the command line, in
      JavaScript, and in Go. The concepts and parameters are largely identical
      between the three languages so they will be presented together here
      instead of having separate documentation for each language.

  - p: >
      There are two main API calls in esbuild's API: [transform](#transform-api)
      and [build](#build-api). It's important to understand which one you should
      be using because they work differently.

  - p: >
      If you are using JavaScript be sure to check out the
      [JS-specific details](#js-specific-details) section below. You may also
      find the [TypeScript type definitions](https://github.com/evanw/esbuild/blob/master/lib/types.ts)
      for esbuild helpful as a reference. If you are using Go be sure to check
      out the automatically generated [Go documentation](https://pkg.go.dev/github.com/evanw/esbuild/pkg/api).

  - h2: Transform API

  - p: >
      The transform API call operates on a single string without access to a
      file system. This makes it ideal for use in environments without a file
      system (such as a browser) or as part of another tool chain. Here is
      what a simple transform looks like:

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' | esbuild --loader=ts
        - expect: |
            let x = 1;

      js:
        - $: |
            require('esbuild').transformSync('let x: number = 1', {
              loader: 'ts',
            })
        - expect: |
            {
              code: 'let x = 1;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("let x: number = 1", api.TransformOptions{
            Loader: api.LoaderTS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      This API call is used by the command-line interface if no input files
      are provided and the `--bundle` flag is not present. In this case the
      input string comes from stdin and the output string goes to stdout.
      The transform API can take the following options:

  - available-options:
    - Banner
    - Charset
    - Color
    - Define
    - Footer
    - Format
    - Global name
    - JSX factory
    - JSX fragment
    - Keep names
    - Loader
    - Log level
    - Log limit
    - Minify
    - Pure
    - Sourcefile
    - Sourcemap
    - Sources Content
    - Target
    - Tree shaking
    - Tsconfig raw

  - h2: Build API

  - p: >
      The build API call operates on one or more files in the file system.
      This allows the files to reference each other and be bundled together.
      Here is what a simple build looks like:

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' > in.ts
        - $: |
            esbuild in.ts --outfile=out.js
        - $: |
            cat out.js
        - expect: |
            let x = 1;

      js:
        - $: |
            require('fs').writeFileSync('in.ts', 'let x: number = 1')
        - $: |
            require('esbuild').buildSync({
              entryPoints: ['in.ts'],
              outfile: 'out.js',
            })
        - expect: |
            { warnings: [] }
        - $: |
            require('fs').readFileSync('out.js', 'utf8')
        - expect: |
            'let x = 1;\n'

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ioutil.WriteFile("in.ts", []byte("let x: number = 1"), 0644)

          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"in.ts"},
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This API call is used by the command-line interface if there is at
      least one input file provided or the `--bundle` flag is present.
      Note that esbuild does _not_ bundle by default. You have to explicitly
      pass the `--bundle` flag to enable bundling. If no input files are
      provided then a single input file is read from stdin. The build API can
      take the following options:

  - available-options:
    - Asset names
    - Banner
    - Bundle
    - Charset
    - Chunk names
    - Color
    - Conditions
    - Define
    - External
    - Footer
    - Format
    - Global name
    - Incremental
    - Inject
    - JSX factory
    - JSX fragment
    - Keep names
    - Loader
    - Log level
    - Log limit
    - Main fields
    - Metafile
    - Minify
    - Node paths
    - Out extension
    - Outbase
    - Outdir
    - Outfile
    - Platform
    - Preserve symlinks
    - Public path
    - Pure
    - Resolve extensions
    - Serve
    - Sourcefile
    - Sourcemap
    - Sources Content
    - Splitting
    - Stdin
    - Target
    - Tree shaking
    - Tsconfig
    - Watch
    - Working Directory
    - Write

  - h2: Simple options

  - h3: Bundle

  - p: >
      To bundle a file means to inline any imported dependencies into the
      file itself. This process is recursive so dependencies of dependencies
      (and so on) will also be inlined. By default esbuild will _not_ bundle
      the input files. Bundling must be explicitly enabled like this:

  - example:
      in:
        in.js: '1 + 2'

      cli: |
          esbuild in.js --bundle

      js:
        - $: |
            require('esbuild').buildSync({
              entryPoints: ['in.js'],
              bundle: true,
              outfile: 'out.js',
            })
        - expect: |
            { warnings: [] }

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"in.js"},
            Bundle:      true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Refer to the [getting started guide](/getting-started/#your-first-bundle)
      for an example of bundling with real-world code.

  - p: >
      Note that bundling is different than file concatenation. Passing
      esbuild multiple input files with bundling enabled will create two
      separate bundles instead of joining the input files together. To join
      a set of files together with esbuild, import them all into a single
      entry point file and bundle just that one file with esbuild.

  - h3: Define

  - p: >
      This feature provides a way to replace global identifiers with
      constant expressions. It can be a way to change the behavior some code
      between builds without changing the code itself:

  - example:
      cli:
        - $: |
            echo 'DEBUG && require("hooks")' | esbuild --define:DEBUG=true
        - expect: |
            require("hooks");

        - $: |
            echo 'DEBUG && require("hooks")' | esbuild --define:DEBUG=false
        - expect: |
            false;

      js:
        - $: let js = 'DEBUG && require("hooks")'

        - $: |
            require('esbuild').transformSync(js, {
              define: { DEBUG: 'true' },
            })
        - expect: |
            {
              code: 'require("hooks");\n',
              map: '',
              warnings: []
            }

        - $: |
            require('esbuild').transformSync(js, {
              define: { DEBUG: 'false' },
            })
        - expect: |
            {
              code: 'false;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "DEBUG && require('hooks')"

          result1 := api.Transform(js, api.TransformOptions{
            Define: map[string]string{"DEBUG": "true"},
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Define: map[string]string{"DEBUG": "false"},
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
      Replacement expressions must either be a JSON object (null, boolean,
      number, string, array, or object) or a single identifier. Replacement
      expressions other than arrays and objects are substituted inline, which
      means that they can participate in constant folding. Array and object
      replacement expressions are stored in a variable and then referenced
      using an identifier instead of being substituted inline, which avoids
      substituting repeated copies of the value but means that the values don't
      participate in constant folding.

  - p: >
      If you want to replace something with a string literal, keep in mind that
      the replacement value passed to esbuild must itself contain quotes.
      Omitting the quotes means the replacement value is an identifier instead:

  - example:
      cli:
        - $: |
            echo 'id, str' | esbuild --define:id=text --define:str=\"text\"
        - expect: |
            text, "text";

      js:
        - $: |
            require('esbuild').transformSync('id, str', {
              define: { id: 'text', str: '"text"' },
            })
        - expect: |
            {
              code: 'text, "text";\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("id, text", api.TransformOptions{
            Define: map[string]string{
              "id":  "text",
              "str": "\"text\"",
            },
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      If you're using the CLI, keep in mind that different shells have different
      rules for how to escape double-quote characters (which are necessary when
      the replacement value is a string). Use a `\"` backslash escape because it
      works in both bash and Windows command prompt. Other methods of escaping
      double quotes that work in bash such as surrounding them with single
      quotes will not work on Windows, since Windows command prompt does not
      remove the single quotes. This is relevant when using the CLI from a npm
      script in your `package.json` file, which people will expect to work on
      all platforms:

  - pre.json: |
      {
        "scripts": {
          "build": "esbuild --define:process.env.NODE_ENV=\\\"production\\\" app.js"
        }
      }

  - p: >
      If you still run into cross-platform quote escaping issues with different
      shells, you will probably want to switch to using the [JavaScript API](/api/)
      instead. There you can use regular JavaScript syntax to eliminate
      cross-platform differences.

  - h3: External

  - p: >
      You can mark a file or a package as external to exclude it from your
      build. Instead of being bundled, the import will be preserved (using
      `require` for the `iife` and `cjs` formats and using `import` for the
      `esm` format) and will be evaluated at run time instead.

  - p: >
      This has several uses. First of all, it can be used to trim unnecessary
      code from your bundle for a code path that you know will never be
      executed. For example, a package may contain code that only runs in node
      but you will only be using that package in the browser. It can also be
      used to import code in node at run time from a package that cannot be
      bundled. For example, the `fsevents` package contains a native extension,
      which esbuild doesn't support. Marking something as external looks like
      this:

  - example:
      cli:
        - $: |
            echo 'require("fsevents")' > app.js
        - $: |
            esbuild app.js --bundle --external:fsevents
        - expect: |
            (() => {
              // app.js
              require("fsevents");
            })();

      js:
        - $: |
            require('fs').writeFileSync('app.js', 'require("fsevents")')
        - $: |
            require('esbuild').buildSync({
              entryPoints: ['app.js'],
              outfile: 'out.js',
              bundle: true,
              external: ['fsevents'],
            })
        - expect: |
            { warnings: [] }

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ioutil.WriteFile("app.js", []byte("require(\"fsevents\")"), 0644)

          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
            External:    []string{"fsevents"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      You can also use the `*` wildcard character in an external path to mark
      all files matching that pattern as external. For example, you can use
      `*.png` to remove all `.png` files or `/images/*` to remove all paths
      starting with `/images/`. When a `*` wildcard character is present in an
      external path, that pattern will be applied to the original path in the
      source code instead of to the path after it has been resolved to a real
      file system path. This lets you match on paths that aren't real file
      system paths.

  - h3: Format

  - p: >
      This sets the output format for the generated JavaScript files. There are
      currently three possible values: `iife`, `cjs`, and `esm`.

  - h4#format-iife: IIFE

  - p: >
      The `iife` format stands for "immediately-invoked function expression" and
      is intended to be run in the browser. Wrapping your code in a function
      expression ensures that any variables in your code don't accidentally
      conflict with variables in the global scope. If your entry point has
      exports that you want to expose as a global in the browser, you can
      configure that global's name using the [global name](#global-name)
      setting. The `iife` format is the default format unless you set
      [platform](#platform) to `node`. Using it looks like this:

  - example:
      cli:
        - $: |
            echo 'alert("test")' | esbuild --format=iife
        - expect: |
            (() => {
              alert("test");
            })();

      js: |
        let js = 'alert("test")'
        let out = require('esbuild').transformSync(js, {
          format: 'iife',
        })
        process.stdout.write(out.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "alert(\"test\")"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatIIFE,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h4#format-commonjs: CommonJS

  - p: >
      The `cjs` format stands for "CommonJS" and is intended to be run in node.
      It assumes the environment contains `exports`, `require`, and `module`.
      Entry points with exports in ECMAScript module syntax will be converted
      to a module with a getter on `exports` for each export name. The `cjs`
      format is the default format when you set [platform](#platform) to `node`.
      Using it looks like this:

  - example:
      cli:
        - $: |
            echo 'export default "test"' | esbuild --format=cjs
        - expect: |
            ...
            __export(exports, {
              default: () => stdin_default
            });
            var stdin_default = "test";

      js: |
        let js = 'export default "test"'
        let out = require('esbuild').transformSync(js, {
          format: 'cjs',
        })
        process.stdout.write(out.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "export default 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatCommonJS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h4#format-esm: ESM

  - p: >
      The `esm` format stands for "ECMAScript module". It assumes the environment
      supports `import` and `export` syntax. Entry points with exports in CommonJS
      module syntax will be converted to a single `default` export of the value
      of `module.exports`. Using it looks like this:

  - example:
      cli:
        - $: |
            echo 'module.exports = "test"' | esbuild --format=esm
        - expect: |
            ...
            var require_stdin = __commonJS((exports, module) => {
              module.exports = "test";
            });
            export default require_stdin();

      js: |
        let js = 'module.exports = "test"'
        let out = require('esbuild').transformSync(js, {
          format: 'esm',
        })
        process.stdout.write(out.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatESModule,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      The `esm` format can be used either in the browser or in node, but you
      have to explicitly load it as a module. This happens automatically if you
      `import` it from another module. Otherwise:

  - ul:
    - >
      In the browser, you can load a module using <code>&lt;script <wbr>src="<wbr>file.js" <wbr>type="<wbr>module"&gt;<wbr>&lt;/script&gt;</code>.
      <br>&nbsp;

    - >
      In node, you can load a module using <code>node <wbr>--experimental-<wbr>modules <wbr>file.mjs</code>.
      Note that node requires the `.mjs` extension unless you have configured
      <code>"type": <wbr>"module"</code> in your `package.json` file.
      You can use the [out extension](#out-extension) setting in esbuild to
      customize the output extension for the files esbuild generates. You can
      read more about using ECMAScript modules in node [here](https://nodejs.org/api/esm.html).

  - h3: Inject

  - p: >
      This option allows you to automatically replace a global variable with an
      import from another file. This can be a useful tool for adapting code that
      you don't control to a new environment. For example, assume you have a
      file called `process-shim.js` that exports a variable named `process`:

  - pre.js: |
      // process-shim.js
      export let process = {
        cwd: () => ''
      }

  - pre.js: |
      // entry.js
      console.log(process.cwd())

  - p: >
      This is intended to replace uses of node's `process.cwd()` function to
      prevent packages that call it from crashing when run in the browser.
      You can use the inject feature to replace all uses of the global identifier
      `process` with an import to that file:

  - example:
      in:
        process-shim.js: 'export let process = { cwd: () => "" }'
        entry.js: 'console.log(process.cwd())'

      cli: |
        esbuild entry.js --bundle --inject:./process-shim.js --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['entry.js'],
          bundle: true,
          inject: ['./process-shim.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"entry.js"},
            Bundle:      true,
            Inject:      []string{"./process-shim.js"},
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      That results in something like this:

  - pre.js: |
      // out.js
      let process = {cwd: () => ""};
      console.log(process.cwd());

  - h4: Using inject with [define](#define)

  - p: >
      You can also combine this with the [define](#define) feature to be more
      selective about what you import. For example:

  - pre.js: |
      // process-shim.js
      export function dummy_process_cwd() {
        return ''
      }

  - pre.js: |
      // entry.js
      console.log(process.cwd())

  - p: >
      You can map `process.cwd` to `dummy_process_cwd` with the [define](#define)
      feature, then inject `dummy_process_cwd` from `process-shim.js` with the
      inject feature:

  - example:
      in:
        process-shim.js: 'export function dummy_process_cwd() { return "" }'
        entry.js: 'console.log(process.cwd())'

      cli: |
        esbuild entry.js --bundle --define:process.cwd=dummy_process_cwd --inject:./process-shim.js --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['entry.js'],
          bundle: true,
          define: { 'process.cwd': 'dummy_process_cwd' },
          inject: ['./process-shim.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"entry.js"},
            Bundle:      true,
            Define: map[string]string{
              "process.cwd": "dummy_process_cwd",
            },
            Inject:  []string{"./process-shim.js"},
            Outfile: "out.js",
            Write:   true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      That results in the following output:

  - pre.js: |
      // out.js
      function dummy_process_cwd() {
        return "";
      }
      console.log(dummy_process_cwd());

  - h4: Auto-import for [JSX](/content-types/#jsx)

  - p: >
      You can use the inject feature to automatically provide the implementation
      for JSX expressions. For example, you can auto-import the `react` package
      to provide functions such as `React.createElement`. See the
      [JSX documentation](/content-types/#auto-import-for-jsx) for details.

  - h4: Injecting files without imports

  - p: >
      You can also use this feature with files that have no exports. In that
      case the injected file just comes first before the rest of the output
      as if every input file contained <code>import <wbr>"./file.js"</code>.
      Because of the way ECMAScript modules work, this injection is still
      "hygienic" in that symbols with the same name in different files are
      renamed so they don't collide with each other.

  - h4: Conditionally injecting a file

  - p: >
      If you want to _conditionally_ import a file only if the export is
      actually used, you should mark the injected file as not having side
      effects by putting it in a package and adding <code>"sideEffects": <wbr>false</code>
      in that package's `package.json` file. This setting is a
      [convention from Webpack](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free)
      that esbuild respects for any imported file, not just files used with inject.

  - h3: Loader

  - p: >
      This option changes how a given input file is interpreted. For example,
      the [`js`](/content-types/#javascript) loader interprets the file as
      JavaScript and the [`css`](/content-types/#css) loader interprets the
      file as CSS. See the [content types](/content-types/) page for a
      complete list of all built-in loaders.

  - p: >
      Configuring a loader for a given file type lets you load that file type
      with an `import` statement or a `require` call. For example, configuring
      the `.png` file extension to use the [data URL](/content-types/#data-url)
      loader means importing a `.png` file gives you a data URL containing the
      contents of that image:

  - pre.js: |
      import url from './example.png'
      let image = new Image
      image.src = url
      document.body.appendChild(image)

      import svg from './example.svg'
      let doc = new DOMParser().parseFromString(svg, 'application/xml')
      let node = document.importNode(doc.documentElement, true)
      document.body.appendChild(node)

  - p: >
      The above code can be bundled using the [build API](#build-api) call like
      this:

  - example:
      in:
        app.js: |
          import url from './example.png'
          let image = new Image
          image.src = url
          document.body.appendChild(image)

          import svg from './example.svg'
          let doc = new DOMParser().parseFromString(svg, 'application/xml')
          let node = document.importNode(doc.documentElement, true)
          document.body.appendChild(node)

        example.png: |
          this is some data

        example.svg: |
          this is some data

      cli: |
        esbuild app.js --bundle --loader:.png=dataurl --loader:.svg=text

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          loader: {
            '.png': 'dataurl',
            '.svg': 'text',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Loader: map[string]api.Loader{
              ".png": api.LoaderDataURL,
              ".svg": api.LoaderText,
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This option is specified differently if you are using the build API with
      input from [stdin](#stdin), since stdin does not have a file extension.
      Configuring a loader for stdin with the build API looks like this:

  - example:
      in:
        pkg.js: |
          module.exports = 123

      cli: |
        echo 'import pkg = require("./pkg")' | esbuild --loader=ts --bundle

      js: |
        require('esbuild').buildSync({
          stdin: {
            contents: 'import pkg = require("./pkg")',
            loader: 'ts',
            resolveDir: __dirname,
          },
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "log"
        import "os"

        func main() {
          cwd, err := os.Getwd()
          if err != nil {
            log.Fatal(err)
          }

          result := api.Build(api.BuildOptions{
            Stdin: &api.StdinOptions{
              Contents:   "import pkg = require('./pkg')",
              Loader:     api.LoaderTS,
              ResolveDir: cwd,
            },
            Bundle: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      The [transform API](#transform-api) call just takes a single loader since
      it doesn't involve interacting with the file system, and therefore doesn't
      deal with file extensions. Configuring a loader (in this case the
      [`ts`](/content-types/#typescript) loader) for the transform API looks
      like this:

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' | esbuild --loader=ts
        - expect: |
            let x = 1;

      js:
        - $: |
            let ts = 'let x: number = 1'
        - $: |
            require('esbuild').transformSync(ts, {
              loader: 'ts',
            })
        - expect: |
            {
              code: 'let x = 1;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          ts := "let x: number = 1"

          result := api.Transform(ts, api.TransformOptions{
            Loader: api.LoaderTS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Minify

  - p: >
      When enabled, the generated code will be minified instead of
      pretty-printed. Minified code is generally equivalent to non-minified
      code but is smaller, which means it downloads faster but is harder to
      debug. Usually you minify code in production but not in development.

  - p: >
      Enabling minification in esbuild looks like this:

  - example:
      cli:
        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify
        - expect: |
            fn=n=>n.x;

      js:
        - $: |
            var js = 'fn = obj => { return obj.x }'
        - $: |
            require('esbuild').transformSync(js, {
              minify: true,
            })
        - expect: |
            {
              code: 'fn=n=>n.x;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "fn = obj => { return obj.x }"

          result := api.Transform(js, api.TransformOptions{
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      This option does three separate things in combination: it removes
      whitespace, it rewrites your syntax to be more compact, and it renames
      local variables to be shorter. Usually you want to do all of these
      things, but these options can also be enabled individually if necessary:

  - example:
      cli:
        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-whitespace
        - expect: |
            fn=obj=>{return obj.x};

        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-identifiers
        - expect: |
            fn = (n) => {
              return n.x;
            };

        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-syntax
        - expect: |
            fn = (obj) => obj.x;

      js:
        - $: |
            var js = 'fn = obj => { return obj.x }'

        - $: |
            require('esbuild').transformSync(js, {
              minifyWhitespace: true,
            })
        - expect: |
            {
              code: 'fn=obj=>{return obj.x};\n',
              map: '',
              warnings: []
            }

        - $: |
            require('esbuild').transformSync(js, {
              minifyIdentifiers: true,
            })
        - expect: |
            {
              code: 'fn = (n) => {\n  return n.x;\n};\n',
              map: '',
              warnings: []
            }

        - $: |
            require('esbuild').transformSync(js, {
              minifySyntax: true,
            })
        - expect: |
            {
              code: 'fn = (obj) => obj.x;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          css := "div { color: yellow }"

          result1 := api.Transform(css, api.TransformOptions{
            Loader:           api.LoaderCSS,
            MinifyWhitespace: true,
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(css, api.TransformOptions{
            Loader:            api.LoaderCSS,
            MinifyIdentifiers: true,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }

          result3 := api.Transform(css, api.TransformOptions{
            Loader:       api.LoaderCSS,
            MinifySyntax: true,
          })

          if len(result3.Errors) == 0 {
            fmt.Printf("%s", result3.Code)
          }
        }

  - p: >
      These same concepts also apply to CSS, not just to JavaScript:

  - example:
      cli:
        - $: |
            echo 'div { color: yellow }' | esbuild --loader=css --minify
        - expect: |
            div{color:#ff0}

      js:
        - $: |
            var css = 'div { color: yellow }'
        - $: |
            require('esbuild').transformSync(css, {
              loader: 'css',
              minify: true,
            })
        - expect: |
            {
              code: 'div{color:#ff0}\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          css := "div { color: yellow }"

          result := api.Transform(css, api.TransformOptions{
            Loader:            api.LoaderCSS,
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      The JavaScript minification algorithm in esbuild usually generates output
      that is very close to the minified output size of industry-standard
      JavaScript minification tools. [This benchmark](https://github.com/privatenumber/minification-benchmarks/tree/cd3e5acb8d38da5f86426d44ac95974812559683#readme)
      has an example comparison of output sizes between different minifiers.
      While esbuild is not the optimal JavaScript minifier in all cases (and
      doesn't try to be), it strives to generate minified output within a few
      percent of the size of dedicated minification tools for most code, and
      of course to do so much faster than other tools.

  - h4#minify-considerations: Considerations

  - p: >
      Here are some things to keep in mind when using esbuild as a minifier:

  - ul:
    - >
      <p>
      You should probably also set the [target](#target) option when
      minification is enabled. By default esbuild takes advantage of modern
      JavaScript features to make your code smaller. For example,
      <code>a ===<wbr> undefined<wbr> || a ===<wbr> null<wbr> ? 1 : a</code>
      could be minified to <code>a ?? 1</code>. If you do not want esbuild
      to take advantage of modern JavaScript features when minifying, you
      should use an older language target such as <code>--target=es6</code>.
      </p>

    - >
      <p>
      Minification is not safe for 100% of all JavaScript code. This is true
      for esbuild as well as for other popular JavaScript minifiers such as
      [terser](https://github.com/terser/terser). In particular, esbuild is
      not designed to preserve the value of calling `.toString()` on a
      function. The reason for this is because if all code inside all
      functions had to be preserved verbatim, minification would hardly do
      anything at all and would be virtually useless. However, this means that
      JavaScript code relying on the return value of `.toString()` will likely
      break when minified. For example, some patterns in the [Angular](https://angular.io/)
      framework break when code is minified because Angular uses `.toString()`
      to read the argument names of functions. A workaround is to not use
      those patterns.
      </p>

    - >
      <p>
      By default esbuild does not preserve the value of `.name` on function
      and class objects. This is because most code doesn't rely on this property
      and using shorter names is an important size optimization. However, some
      code does rely on the `.name` property for registration and binding
      purposes. If you need to rely on this you should enable the
      [keep names](#keep-names) option.
      </p>

    - |
      <p>
      Use of certain JavaScript features can disable many of esbuild's
      optimizations including minification. Specifically, using direct `eval`
      and/or the `with` statement prevent esbuild from renaming identifiers
      to smaller names since these features cause identifier binding to happen
      at run time instead of compile time. This is almost always unintentional,
      and only happens because people are unaware of what direct `eval` is and
      why it's bad.
      </p>
      <p>
      If you are thinking about writing some code like this:
      </p>
      <pre>
      // Direct eval (will disable minification for the whole file)
      let result = eval(something)
      </pre>
      <p>
      You should probably write your code like this instead so your code can be minified:
      </p>
      <pre>
      // Indirect eval (has no effect on the surrounding code)
      let result = (0, eval)(something)
      </pre>
      <p>
      There is more information about the consequences of direct `eval` and the
      available alternatives [here](/content-types/#direct-eval).
      </p>

    - >
      <p>
      The minification algorithm in esbuild does not yet do advanced code
      optimizations. In particular, the following code optimizations are
      possible for JavaScript code but are not done by esbuild (not an
      exhaustive list):
      </p>
      <ul>
        <li>Dead-code elimination within function bodies</li>
        <li>Function inlining</li>
        <li>Cross-statement constant propagation</li>
        <li>Object shape modeling</li>
        <li>Allocation sinking</li>
        <li>Method devirtualization</li>
        <li>Symbolic execution</li>
        <li>JSX expression hoisting</li>
        <li>TypeScript enum detection and inlining</li>
      </ul>
      <p>
      If your code makes use of patterns that require some of these forms of
      code optimization to be compact, or if you are searching for the optimal
      JavaScript minification algorithm for your use case, you should consider
      using other tools. Some examples of tools that implement some of these
      advanced code optimizations include [Terser](https://github.com/terser/terser#readme)
      and [Google Closure Compiler](https://github.com/google/closure-compiler#readme).
      </p>

  - h3: Outdir

  - p: >
      This option sets the output directory for the build operation. For
      example, this command will generate a directory called `out`:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      The output directory will be generated if it does not already exist, but
      it will not be cleared if it already contains some files. Any generated
      files will silently overwrite existing files with the same name. You
      should clear the output directory yourself before running esbuild if you
      want the output directory to only contain files from the current run of
      esbuild.

  - p: >
      If your build contains multiple entry points in separate directories, the
      directory structure will be replicated into the output directory starting
      from the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor)
      directory among all input entry point paths. For example, if there are
      two entry points <code>src/<wbr>home/<wbr>index.ts</code> and
      <code>src/<wbr>about/<wbr>index.ts</code>, the output directory will
      contain <code>home/<wbr>index.js</code> and <code>about/<wbr>index.js</code>.
      If you want to customize this behavior, you should change the
      [outbase directory](#outbase).

  - h3: Outfile

  - p: >
      This option sets the output file name for the build operation. This is
      only applicable if there is a single entry point. If there are multiple
      entry points, you must use the [outdir](#outdir) option instead to
      specify an output directory. Using outfile looks like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Platform

  - p: >
      By default, esbuild's bundler is configured to generate code intended for
      the browser. If your bundled code is intended to run in node instead, you
      should set the platform to `node`:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --platform=node

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          platform: 'node',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      When the platform is set to `browser` (the default value):

  - ul:
    - >
      <p>
      The default output [format](#format) is set to `iife`, which wraps the
      generated JavaScript code in an immediately-invoked function expression
      to prevent variables from leaking into the global scope.
      </p>
    - >
      <p>
      If a package specifies a map for the
      [`browser`](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)
      field in its `package.json` file, esbuild will use that map to replace
      specific files or modules with their browser-friendly versions. For
      example, a package might contain a substitution of [`path`](https://nodejs.org/api/path.html)
      with [`path-browserify`](https://www.npmjs.com/package/path-browserify).
      </p>
    - >
      <p>
      The [main fields](#main-fields) setting is set to <code>browser,<wbr>module,<wbr>main</code>
      but with some additional special behavior. If a package supports `module`
      and `main` but not `browser` then `main` is used instead of `module` if
      that package is ever imported using `require()`. This behavior improves
      compatibility with CommonJS modules that export a function by assigning
      it to `module.exports`.
      </p>
    - >
      <p>
      The [conditions](#conditions) setting automatically includes the `browser`
      condition. This changes how the `exports` field in `package.json` files
      is interpreted to prefer browser-specific code.
      </p>
    - >
      <p>
      To avoid warning about the use of `require` in code generated by Browserify,
      the specific expression <code>typeof <wbr>require <wbr>== <wbr>'function' <wbr>&& <wbr>require</code>
      is substituted with `false`. This code is present in some packages that
      have been published to npm.
      </p>

  - p: >
      When the platform is set to `node`:

  - ul:
    - >
      <p>
      The default output [format](#format) is set to `cjs`, which stands for
      CommonJS (the module format used by node). ES6-style exports using
      `export` statements will be converted into getters on the CommonJS
      `exports` object.
      </p>
    - >
      <p>
      All [built-in node modules](https://nodejs.org/docs/latest/api/) such
      as `fs` are automatically marked as [external](#external) so they don't
      cause errors when the bundler tries to bundle them.
      </p>
    - >
      <p>
      The [main fields](#main-fields) setting is set to <code>main,<wbr>module</code>. This
      means tree shaking will likely not happen for packages that provide both
      `module` and `main` since tree shaking works with ECMAScript modules but
      not with CommonJS modules.
      </p>
      <p>
      Unfortunately some packages incorrectly treat `module` as meaning "browser
      code" instead of "ECMAScript module code" so this default behavior is
      required for compatibility. You can manually configure the [main fields](#main-fields)
      setting to <code>module,<wbr>main</code> if you want to enable tree shaking and know it
      is safe to do so.
      </p>
    - >
      <p>
      The [conditions](#conditions) setting automatically includes the `node`
      condition. This changes how the `exports` field in `package.json` files
      is interpreted to prefer node-specific code.
      </p>

  - p: >
      When the platform is set to `neutral`:

  - ul:
    - >
      <p>
      The default output [format](#format) is set to `esm`, which uses the
      `export` syntax introduced with ECMAScript 2015 (i.e. ES6). You can change
      the output format if this default is not appropriate.
      </p>
    - >
      <p>
      The [main fields](#main-fields) setting is empty by default. If you want
      to use npm-style packages, you will likely have to configure this to be
      something else such as `main` for the standard main field used by node.
      </p>
    - >
      <p>
      The [conditions](#conditions) setting does not automatically include any
      platform-specific values.
      </p>

  - p: >
      See also [bundling for the browser](/getting-started/#bundling-for-the-browser)
      and [bundling for node](/getting-started/#bundling-for-node).

  - h3: Serve

  - p: >
      During development, it's common to switch back and forth between a text
      editor and a browser while making changes. It's inconvenient to manually
      re-run esbuild before reloading your code in the browser. There are
      several methods to automate this:

  - ul:
    - Use [watch mode](#watch) to re-run esbuild when a file is changed
    - Configure your text editor to run esbuild every time you save
    - Serve your code with a web server that rebuilds on every request

  - p: >
      This API call implements the last method. The serve API is similar to the
      [build API](#build-api) call but instead of writing the generated files
      to the file system, it starts a long-lived local HTTP web server that
      serves the generated files from the latest build. Each new batch of
      requests causes esbuild to re-run the build command before responding to
      the requests so your files are always up to date.

  - p: >
      The advantage of this method over the other methods is that the web server
      can delay the browser's request until the build has finished. That way
      reloading your code in the browser before the latest build has finished
      will never run code from a previous build. The files are served from memory
      and are not written to the file system to ensure that the outdated files
      cannot be observed.

  - p: >
      Note that this is intended to only be used in development. _Do not use
      this in production._ In production you should be serving static files
      without using esbuild as a web server.

  - p: >
      There are two different approaches for using the serve API:

  - h4#serve-everything: 'Approach 1: Serve everything with esbuild'

  - p: >
      With this approach, you give esbuild a directory called `servedir` with
      extra content to serve in addition to the files that esbuild generates.
      This works well for simple situations where you are creating some static
      HTML pages and want to use esbuild to bundle the JavaScript and/or CSS.
      You can put your HTML files in the `servedir` and your other source code
      outside of the `servedir`, then set the [`outdir`](#outdir) somewhere
      inside the `servedir`:

  - example:
      noCheck: true

      cli: |
        esbuild src/app.js --servedir=www --outdir=www/js --bundle

      js: |
        require('esbuild').serve({
          servedir: 'www',
        }, {
          entryPoints: ['src/app.js'],
          outdir: 'www/js',
          bundle: true,
        }).then(server => {
          // Call "stop" on the web server when you're done
          server.stop()
        })

      go: |
        server, err := api.Serve(api.ServeOptions{
          Servedir: "www",
        }, api.BuildOptions{
          EntryPoints: []string{"src/app.js"},
          Outdir:      "www/js",
          Bundle:      true,
        })

        // Call "stop" on the web server when you're done
        server.Stop()

  - p: >
      In the above example, your `www/index.html` page could reference the
      compiled code in `src/app.js` like this:

  - pre.html: |
      <script src="js/app.js"></script>

  - p: >
      When you do this, every HTTP request will cause esbuild to rebuild your
      code and serve you the latest version. So `js/app.js` will always be up
      to date every time you reload the page. Note that although the generated
      code appears to be inside the `outdir` directory, it's never actually
      written to the file system with the serve API. Instead the paths for
      generated code shadow (i.e. takes precedence over) other paths inside the
      `servedir` and generated files are served directly from memory.

  - p: >
      The benefit of doing things this way is that you can use the exact same
      HTML pages in development and production. In development you can run
      esbuild with `--servedir=` and esbuild will serve the generated output
      files directly. For production you can omit that flag and esbuild will
      write the generated files to the file system. In both cases you should
      be getting the exact same result in the browser with the exact same code
      in both development and production.

  - p: >
      The port is automatically chosen by default as the first open port
      equal to or greater than 8000. The port number is returned from the API
      call (or printed to the terminal for the CLI) so you can know which URL
      to visit. The port can be set to something specific if necessary
      (described further down below).

  - h4#serve-generated: 'Approach 2: Only serve generated files with esbuild'

  - p: >
      With this approach, you just tell esbuild to serve the contents of the
      [`outdir`](#outdir) without giving it any additional content to serve.
      This works well for more complex development setups. For example, you
      might want to use NGINX as a reverse proxy to route different paths to
      separate backend services during development (e.g. `/static/` to NGINX,
      `/api/` to node, `/js/` to esbuild, etc.). Using esbuild with this
      approach looks like this:

  - example:
      noCheck: true

      cli: |
        esbuild src/app.js --outfile=out.js --bundle --serve=8000

      js: |
        require('esbuild').serve({
          port: 8000,
        }, {
          entryPoints: ['src/app.js'],
          bundle: true,
          outfile: 'out.js',
        }).then(server => {
          // Call "stop" on the web server when you're done
          server.stop()
        })

      go: |
        server, err := api.Serve(api.ServeOptions{
          Port: 8000,
        }, api.BuildOptions{
          EntryPoints: []string{"src/app.js"},
          Bundle:      true,
          Outfile:     "out.js",
        })

        // Call "stop" on the web server when you're done
        server.Stop()

  - p: >
      The API call in the above example would serve the compiled contents of
      `src/app.js` at [http://localhost:8000/out.js](http://localhost:8000/out.js).
      Just like with the first approach, every HTTP request will cause esbuild
      to rebuild your code and serve you the latest version so `out.js` will
      always be up to date. Your HTML file (served by another web server on
      another port) could then reference the compiled file from your HTML like
      this:

  - pre.html: |
      <script src="http://localhost:8000/out.js"></script>

  - p: >
      The URL structure of the web server exactly mirrors the URL structure of
      the [output directory](#outdir) when using the normal build command
      without the web server enabled. For example, if the output directory
      normally contains a file called <code>./pages/<wbr>about.js</code>, the
      web server will have a corresponding <code>/pages/<wbr>about.js</code>
      path.

  - p: >
      If you would like to browse the web server to see what URLs are available,
      you can use the built-in directory listing by visiting a directory name
      instead of a file name. For example, if you're running esbuild's web
      server on port 8000 you can visit [http://<wbr>localhost:<wbr>8000/](http://localhost:8000/)
      in your browser to view the web server's root directory. From there you
      can click on links to browse to different files and directories on the
      web server.

  - h4#serve-arguments: Arguments

  - p: >
      Notice that the serve API is a different API call than the [build API](#build-api).
      This is because starting a long-running web server is different enough to
      warrant different arguments and return values. The first argument to the
      serve API call is an options object with serve-specific options:

  - example:
      noCheck: true

      js: |
        interface ServeOptions {
          port?: number;
          host?: string;
          servedir?: string;
          onRequest?: (args: ServeOnRequestArgs) => void;
        }

        interface ServeOnRequestArgs {
          remoteAddress: string;
          method: string;
          path: string;
          status: number;
          timeInMS: number;
        }

      go: |
        type ServeOptions struct {
          Port      uint16
          Host      string
          Servedir  string
          OnRequest func(ServeOnRequestArgs)
        }

        type ServeOnRequestArgs struct {
          RemoteAddress string
          Method        string
          Path          string
          Status        int
          TimeInMS      int
        }

  - ul:
    - >
      `port`
      <p>
      The HTTP port can optionally be configured here. If omitted, it will
      default to an open port with a preference for port 8000. You can set the
      port on the command line by using `--serve=8000` instead of just `--serve`.
      </p>

    - >
      `host`
      <p>
      By default, esbuild makes the web server available on all IPv4 network
      interfaces. This corresponds to a host address of `0.0.0.0`. If you would
      like to configure a different host (for example, to only serve on the
      `127.0.0.1` loopback interface without exposing anything to the network),
      you can specify the host using this argument. You can set the host on the
      command line by using <code>--serve=<wbr>127.0.0.1:<wbr>8000</code>
      instead of just `--serve`.
      </p>
      <p>
      If you need to use IPv6 instead of IPv4, you just need to specify an IPv6
      host address. The equivalent to the `127.0.0.1` loopback interface in IPv6
      is `::1` and the equivalent to the `0.0.0.0` universal interface in IPv6 is
      `::`. If you are setting the host to an IPv6 address on the command line,
      you need to surround the IPv6 address with square brackets to distinguish
      the colons in the address from the colon separating the host and port
      like this: <code>--serve=<wbr>[::]:<wbr>8000</code>.
      </p>

    - >
      `servedir`
      <p>
      This is a directory of extra content for esbuild's HTTP server to serve
      instead of a 404 when incoming requests don't match any of the generated
      output file paths. This lets you use esbuild as a general-purpose local
      web server. For example, using <code>esbuild <wbr>--servedir=.</code>
      serves the current directory on `localhost`. Using `servedir` is described
      in more detail above in the previous section about different approaches.
      </p>

    - >
      `onRequest`
      <p>
      This is called once for each incoming request with some information about
      the request. This callback is used by the CLI to print out a log message
      for each request. The time field is the time to generate the data for the
      request, but it does not include the time to stream the request to the
      client.
      </p>
      <p>
      Note that this is called after the request has completed. It's not possible
      to use this callback to modify the request in any way. If you want to do
      this, you should [put a proxy in front of esbuild](#customizing-server-behavior) instead.
      </p>

  - p: >
      The second argument to the serve API call is the normal set of options
      for the underlying build API that is called on every request. See the
      documentation for the [build API](#build-api) for more information about
      these options.

  - h4#serve-return-values: Return values

  - example:
      noCheck: true

      js: |
        interface ServeResult {
          port: number;
          host: string;
          wait: Promise<void>;
          stop: () => void;
        }

      go: |
        type ServeResult struct {
          Port uint16
          Host string
          Wait func() error
          Stop func()
        }

  - ul:
    - >
      `port`
      <p>
      This is the port that ended up being used by the web server. You'll want to
      use this if you don't specify a port since esbuild will end up picking
      an arbitrary open port, and you need to know which port it picked to be
      able to connect to it. If you're using the CLI, this port number will be
      printed to stderr in the terminal.
      </p>

    - >
      `host`
      <p>
      This is the port that ended up being used by the web server. It will be
      `0.0.0.0` (i.e. serving on all available network interfaces) unless a
      custom host was configured.
      </p>

    - >
      `wait`
      <p>
      The serve API call returns immediately as long as the socket was able to
      be opened. The `wait` return value provides a way to be informed when the
      web server is terminated, either due to a network error or due to `stop`
      being called at some point in the future.
      </p>

    - >
      `stop`
      <p>
      Call this callback to stop the web server, which you should do when you no
      longer need it to clean up resources. This will immediately terminate
      all open connections and wake up any code waiting on the `wait` return
      value.
      </p>

  - h4: Customizing server behavior

  - p: >
      It's not possible to hook into esbuild's local server to customize the
      behavior of the server itself. Instead, behavior should be customized
      by putting a proxy in front of esbuild.

  - p: >
      Here's a simple example of a proxy server to get you started. It adds a
      custom 404 page instead of esbuild's default 404 page:

  - pre.js: |
      const esbuild = require('esbuild');
      const http = require('http');

      // Start esbuild's server on a random local port
      esbuild.serve({
        servedir: __dirname,
      }, {
        // ... your build options go here ...
      }).then(result => {
        // The result tells us where esbuild's local server is
        const {host, port} = result

        // Then start a proxy server on port 3000
        http.createServer((req, res) => {
          const options = {
            hostname: host,
            port: port,
            path: req.url,
            method: req.method,
            headers: req.headers,
          }

          // Forward each incoming request to esbuild
          const proxyReq = http.request(options, proxyRes => {
            // If esbuild returns "not found", send a custom 404 page
            if (proxyRes.statusCode === 404) {
              res.writeHead(404, { 'Content-Type': 'text/html' });
              res.end('<h1>A custom 404 page</h1>');
              return;
            }

            // Otherwise, forward the response from esbuild to the client
            res.writeHead(proxyRes.statusCode, proxyRes.headers);
            proxyRes.pipe(res, { end: true });
          });

          // Forward the body of the request to esbuild
          req.pipe(proxyReq, { end: true });
        }).listen(3000);
      });

  - p: >
      This code starts esbuild's server on random local port and then starts a
      proxy server on port 3000. During development you would load [http://localhost:3000](http://localhost:3000)
      in your browser, which talks to the proxy. This example demonstrates
      modifying a response after esbuild has handled the request, but you can
      also modify or replace the request before esbuild has handled it.

  - p: >
      You can do many things with a proxy like this including:

  - ul:
    - Injecting your own 404 page (the example above)
    - Customizing the mapping of routes to files on the file system
    - Redirecting some routes to an API server instead of to esbuild
    - Adding support for HTTPS using your own self-signed certificates

  - p: >
      You can also use a real proxy such as [NGINX](https://nginx.org/en/docs/beginners_guide.html#proxy)
      if you have more advanced needs.

  - h3: Sourcemap

  - p: >
      Source maps can make it easier to debug your code. They encode the
      information necessary to translate from a line/column offset in a
      generated output file back to a line/column offset in the corresponding
      original input file. This is useful if your generated code is
      sufficiently different from your original code (e.g. your original code
      is TypeScript or you enabled [minification](#minify)).

  - p: >
      Enabling source map generation will generate a `.js.map` file alongside
      any generated `.js` file and add a special `//# sourceMappingURL=` comment
      to the bottom of the `.js` file pointing to the `.js.map` file:

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapLinked,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If the input file itself contains a special `//# sourceMappingURL=`
      comment, esbuild will automatically try to parse the linked source map.
      If successful, the mappings in the generated source map will map all the
      way back to the original source code referenced in the input source map.

  - p: >
      If you want to omit the special `//# sourceMappingURL=` comment from the
      generated `.js` file but you still want to generate the `.js.map` files,
      you should set the source map mode to `external`:

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=external --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'external',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If you want to insert the entire source map into the `.js` file instead
      of generating a separate `.js.map` file, you should set the source map
      mode to `inline`:

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=inline --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'inline',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInline,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Keep in mind that source maps are usually very big because they contain
      all of your original source code, so you usually do not want to ship code
      containing `inline` source maps. To remove the source code from the source
      map (keeping only the file names and the line/column mappings), use the
      [sources content](#sources-content) option.

  - p: >
      If you want to have the effect of both `inline` and `external`
      simultaneously, you should set the source map mode to `both`:

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=both --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'both',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInlineAndExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4: Using source maps

  - p: >
      In the browser, source maps should be automatically picked up by the
      browser's developer tools as long as the source map setting is enabled.
      Note that the browser only uses the source maps to alter the display of
      stack traces when they are logged to the console. The stack traces
      themselves are not modified so inspecting <code>error.<wbr>stack</code>
      in your code will still give the unmapped stack trace containing compiled
      code. Here's how to enable this setting in your browser's developer tools:

  - ul:
      - 'Chrome: ⚙ → Enable JavaScript source maps'
      - 'Safari: ⚙ → Sources → Enable source maps'
      - 'Firefox: ··· → Enable Source Maps'

  - p: >
      In node, source maps are supported natively starting with [version v12.12.0](https://nodejs.org/en/blog/release/v12.12.0/).
      This feature is disabled by default but can be enabled with a flag. Unlike
      in the browser, the actual stack traces are also modified in node so
      inspecting <code>error.<wbr>stack</code> in your code will give the mapped
      stack trace containing your original source code. Here's how to enable this
      setting in node (the <code>--enable-<wbr>source-<wbr>maps</code> flag must
      come before the script file name):

  - pre.sh: |
      node --enable-source-maps app.js

  - h3: Splitting

  - warning: >
      Code splitting is still a work in progress. It currently only works with
      the `esm` output [format](#format). There is also a known
      [ordering issue](https://github.com/evanw/esbuild/issues/399) with
      `import` statements across code splitting chunks. You can follow
      [the tracking issue](https://github.com/evanw/esbuild/issues/16) for
      updates about this feature.

  - p: >
      This enables "code splitting" which serves two purposes:

  - ul:
      - >
        <p>
        Code shared between multiple entry points is split off into a separate
        shared file that both entry points import. That way if the user first
        browses to one page and then to another page, they don't have to
        download all of the JavaScript for the second page from scratch if the
        shared part has already been downloaded and cached by their browser.
        </p>

      - >
        <p>
        Code referenced through an asynchronous `import()` expression will be
        split off into a separate file and only loaded when that expression is
        evaluated. This allows you to improve the initial download time of your
        app by only downloading the code you need at startup, and then lazily
        downloading additional code if needed later.
        </p>
        <p>
        Without code splitting enabled, an `import()` expression becomes
        <code>Promise<wbr>.resolve()<wbr>.then(() =&gt; <wbr>require())</code>
        instead. This still preserves the asynchronous semantics of the
        expression but it means the imported code is included in the same
        bundle instead of being split off into a separate file.
        </p>

  - p: >
      When you enable code splitting you must also configure the output
      directory using the [outdir](#outdir) setting:

  - example:
      in:
        home.ts: '1 + 2'
        about.ts: '1 + 2'

      cli: |
        esbuild home.ts about.ts --bundle --splitting --outdir=out --format=esm

      js: |
        require('esbuild').buildSync({
          entryPoints: ['home.ts', 'about.ts'],
          bundle: true,
          splitting: true,
          outdir: 'out',
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"home.ts", "about.ts"},
            Bundle:      true,
            Splitting:   true,
            Outdir:      "out",
            Format:      api.FormatESModule,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Target

  - p: >
      This sets the target environment for the generated JavaScript code. For
      example, you can configure esbuild to not generate any newer JavaScript
      that node version 10 can't handle. The target can either be set to a
      JavaScript language version such as `es2020` or to a list of versions of
      individual engines (currently either `chrome`, `firefox`, `safari`, `edge`,
      or `node`). The default target is `esnext` which means that by default,
      esbuild will assume all of the latest JavaScript features are supported.

  - p: >
      Here is an example that uses all of the available target environment names
      in esbuild. Note that you don't need to specify all of them; you can just
      specify the subset of target environments that your project cares about.
      You can also be more precise about version numbers if you'd like (e.g.
      `node12.19.0` instead of just `node12`):

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --target=es2020,chrome58,firefox57,safari11,edge16,node12

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          target: [
            'es2020',
            'chrome58',
            'firefox57',
            'safari11',
            'edge16',
            'node12',
          ],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Target:      api.ES2020,
            Engines: []api.Engine{
              {Name: api.EngineChrome, Version: "58"},
              {Name: api.EngineFirefox, Version: "57"},
              {Name: api.EngineSafari, Version: "11"},
              {Name: api.EngineEdge, Version: "16"},
              {Name: api.EngineNode, Version: "12"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      You can refer to the [JavaScript loader](/content-types/#javascript) for
      the details about which syntax features were introduced with which language
      versions. Keep in mind that while JavaScript language versions such as
      `es2020` are identified by year, that is the year the specification is
      approved. It has nothing to do with the year all major browsers implement
      that specification which often happens earlier or later than that year.

  - p: >
      Note that if you use a syntax feature that esbuild doesn't yet have
      support for transforming to your current language target, esbuild will
      generate an error where the unsupported syntax is used. This is often the
      case when targeting the `es5` language version, for example, since esbuild
      only supports transforming most newer JavaScript syntax features to `es6`.

  - h3: Watch

  - p: >
      Enabling watch mode on the build API tells esbuild to listen for changes
      on the file system and to rebuild whenever a file changes that could
      invalidate the build. Using it looks like this:

  - example:
      noCheck: true

      cli: |
        esbuild app.js --outfile=out.js --bundle --watch

      js: |
        require('esbuild').build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          watch: true,
        }).then(result => {
          // Call "stop" on the result when you're done
          result.stop()
        })

      go: |
        result := api.Build(api.BuildOptions{
          EntryPoints: []string{"app.js"},
          Outfile:     "out.js",
          Bundle:      true,
          Watch:       &api.WatchMode{},
        })

        // Call "stop" on the result when you're done
        result.Stop()

  - p: >
      If you are using the JavaScript or Go API, you can optionally provide a
      callback that will be called whenever an incremental build has completed.
      This can be used to do something once the build is complete (e.g. to
      reload your app in the browser):

  - example:
      noCheck: true

      js: |
        require('esbuild').build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          watch: {
            onRebuild(error, result) {
              if (error) console.error('watch build failed:', error)
              else console.error('watch build succeeded:', result)
            },
          },
        }).then(result => {
          // Call "stop" on the result when you're done
          result.stop()
        })

      go: |
        result := api.Build(api.BuildOptions{
          EntryPoints: []string{"app.js"},
          Outfile:     "out.js",
          Bundle:      true,
          Watch: &api.WatchMode{
            OnRebuild: func(result api.BuildResult) {
              if len(result.Errors) > 0 {
                fmt.Printf("watch build failed: %d errors\n", len(result.Errors))
              } else {
                fmt.Printf("watch build succeeded: %d warnings\n", len(result.Warnings))
              }
            },
          },
        })

        // Call "stop" on the result when you're done
        result.Stop()

  - p: >
      Watch mode in esbuild is implemented using polling instead of OS-specific
      file system APIs for portability. The polling system is designed to use
      relatively little CPU vs. a more traditional polling system that scans
      the whole directory tree at once. The file system is still scanned
      regularly but each scan only checks a random subset of your files, which
      means a change to a file will be picked up soon after the change is made
      but not necessarily instantly.

  - p: >
      With the current heuristics, large projects should be completely scanned
      around every 2 seconds so in the worst case it could take up to 2 seconds
      for a change to be noticed. However, after a change has been noticed the
      change's path goes on a short list of recently changed paths which are
      checked on every scan, so further changes to recently changed files
      should be noticed almost instantly.

  - p: >
      Note that it is still possible to implement watch mode yourself using
      esbuild's [incremental build API](#incremental) and a file watcher library
      of your choice if you don't want to use a polling-based approach.

  - h3: Write

  - p: >
      The build API call can either write to the file system directly or return
      the files that would have been written as in-memory buffers. By default
      the CLI and JavaScript APIs write to the file system and the Go API
      doesn't. To use the in-memory buffers:

  - example:
      in:
        app.js: '1 + 2'

      js: |
        let result = require('esbuild').buildSync({
          entryPoints: ['app.js'],
          sourcemap: 'external',
          write: false,
          outdir: 'out',
        })

        for (let out of result.outputFiles) {
          console.log(out.path, out.contents)
        }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Sourcemap:   api.SourceMapExternal,
            Write:       false,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          for _, out := range result.OutputFiles {
            fmt.Printf("%v %v\n", out.Path, out.Contents)
          }
        }

  - h2: Advanced options

  - h3: Asset names

  - p: >
      This option controls the file names of the additional output files generated
      when the [loader](#loader) is set to [`file`](/content-types/#external-file).
      It configures the output paths using a template with placeholders that will
      be substituted with values specific to the file when the output path is
      generated. For example, specifying an asset name template of
      <code>assets/<wbr>[name]-<wbr>[hash]</code> puts all assets into a
      subdirectory called `assets` inside of the output directory and includes
      the content hash of the asset in the file name. Doing that looks like this:

  - example:
      in:
        app.js: 'import "./file.png"'
        file.png: 'a png file'

      cli: |
        esbuild app.js --asset-names=assets/[name]-[hash] --loader:.png=file --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          assetNames: 'assets/[name]-[hash]',
          loader: { '.png': 'file' },
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            AssetNames:  "assets/[name]-[hash]",
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Bundle: true,
            Outdir: "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      There are two placeholders that can be used in asset path templates:

  - ul:
    - >
      `[name]`
      <p>
      This is the original file name of the asset without the extension. For
      example, if the asset was originally named `image.png` then `[name]` will
      be substituted with `image` in the template. It is not necessary to use
      this placeholder; it only exists to provide human-friendly asset names to
      make debugging easier.
      </p>

    - >
      `[hash]`
      <p>
      This is the content hash of the asset, which is useful to avoid name
      collisions. For example, your code may import <code>components/<wbr>button/<wbr>icon.png</code>
      and <code>components/<wbr>select/<wbr>icon.png</code> in which case
      you'll need the hash to distinguish between the two assets that are both
      named `icon`.
      </p>

  - p: >
      Asset path templates do not need to include a file extension. The original
      file extension of the asset will be automatically added to the end of the
      output path after template substitution.

  - p: >
      This option is similar to the [chunk names](#chunk-names) option.

  - h3: Banner

  - p: >
      Use this to insert an arbitrary string at the beginning of generated
      JavaScript and CSS files. This is commonly used to insert comments:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --banner:js=//comment --banner:css=/*comment*/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          banner: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Banner: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This is similar to [footer](#footer) which inserts at the end instead
      of the beginning.

  - p: >
      Note that if you are inserting non-comment code into a CSS file, be aware
      that CSS ignores all `@import` rules that come after a non-`@import` rule
      (other than a `@charset` rule), so using a banner to inject CSS rules may
      accidentally disable imports of external stylesheets.

  - h3: Charset

  - p: >
      By default esbuild's output is ASCII-only. Any non-ASCII characters are
      escaped using backslash escape sequences. One reason is because non-ASCII
      characters are misinterpreted by the browser by default, which causes
      confusion. You have to explicitly add <code>&lt;meta <wbr>charset=<wbr>"utf-8"&gt;</code> to your
      HTML or serve it with the correct <code>Content-<wbr>Type</code> header for the browser
      to not mangle your code. Another reason is that non-ASCII characters can
      significantly [slow down the browser's parser](https://v8.dev/blog/scanner).
      However, using escape sequences makes the generated output slightly bigger,
      and also makes it harder to read.

  - p: >
      If you would like for esbuild to print the original characters without
      using escape sequences and you have ensured that the browser will
      interpret your code as UTF-8, you can disable character escaping by
      setting the charset:

  - example:
      cli:
        - $: |
            echo 'let π = Math.PI' | esbuild
        - expect: |
            let \u03C0 = Math.PI;
        - $: |
            echo 'let π = Math.PI' | esbuild --charset=utf8
        - expect: |
            let π = Math.PI;

      js:
        - $: |
            let js = 'let π = Math.PI'
        - $: |
            require('esbuild').transformSync(js)
        - expect: |
            {
              code: 'let \\u03C0 = Math.PI;\n',
              map: '',
              warnings: []
            }
        - $: |
            require('esbuild').transformSync(js, {
              charset: 'utf8',
            })
        - expect: |
            {
              code: 'let π = Math.PI;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "let π = Math.PI"

          result1 := api.Transform(js, api.TransformOptions{})

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Charset: api.CharsetUTF8,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
      Some caveats:

  - ul:
    - >
      <p>
      This does not yet escape non-ASCII characters embedded in regular
      expressions. This is because esbuild does not currently parse the contents
      of regular expressions at all. The flag was added despite this limitation
      because it's still useful for code that doesn't contain cases like this.
      </p>
    - >
      <p>
      This flag does not apply to comments. I believe preserving non-ASCII data
      in comments should be fine because even if the encoding is wrong, the run
      time environment should completely ignore the contents of all comments.
      For example, the [V8 blog post](https://v8.dev/blog/scanner) mentions an
      optimization that avoids decoding comment contents completely. And all
      comments other than license-related comments are stripped out by esbuild
      anyway.
      </p>
    - >
      <p>
      This option simultaneously applies to all output file types (JavaScript,
      CSS, and JSON). So if you configure your web server to send the correct
      <code>Content-<wbr>Type</code> header and want to use the UTF-8 charset,
      make sure your web server is configured to treat both `.js` and `.css`
      files as UTF-8.
      </p>

  - h3: Chunk names

  - p: >
      This option controls the file names of the chunks of shared code that are
      automatically generated when [code splitting](#splitting) is enabled.
      It configures the output paths using a template with placeholders that will
      be substituted with values specific to the chunk when the output path is
      generated. For example, specifying a chunk name template of
      <code>chunks/<wbr>[name]-<wbr>[hash]</code> puts all generated chunks into
      a subdirectory called `chunks` inside of the output directory and includes
      the content hash of the chunk in the file name. Doing that looks like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --chunk-names=chunks/[name]-[hash] --bundle --outdir=out --splitting --format=esm

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          chunkNames: 'chunks/[name]-[hash]',
          bundle: true,
          outdir: 'out',
          splitting: true,
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            ChunkNames:  "chunks/[name]-[hash]",
            Bundle:      true,
            Outdir:      "out",
            Splitting:   true,
            Format:      api.FormatESModule,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      There are two placeholders that can be used in chunk path templates:

  - ul:
    - >
      `[name]`
      <p>
      This will currently always be the text `chunk`, although this placeholder
      may take on additional values in future releases.
      </p>

    - >
      `[hash]`
      <p>
      This is the content hash of the chunk. Including this is necessary to
      distinguish different chunks from each other in the case where multiple
      chunks of shared code are generated.
      </p>

  - p: >
      Chunk path templates do not need to include a file extension. The
      configured [out extension](#out-extension) for the appropriate content
      type will be automatically added to the end of the output path after
      template substitution.

  - p: >
      Note that this option only controls the names for automatically-generated
      chunks of shared code. It does _not_ control the names for output files
      related to entry points. The names of these are currently determined from
      the path of the original entry point file relative to the [outbase](#outbase)
      directory, and this behavior cannot be changed. An additional API option
      will be added in the future to let you change the file names of entry
      point output files.

  - p: >
      This option is similar to the [asset names](#asset-names) option.

  - h3: Color

  - p: >
      This option enables or disables colors in the error and warning messages
      that esbuild writes to stderr file descriptor in the terminal. By
      default, color is automatically enabled if stderr is a TTY session and
      automatically disabled otherwise. Colored output in esbuild looks like this:

  - pre.raw: |
      <b> &gt; example.js: <span class="color-red">error:</span> Could not resolve "logger" (mark it as external to exclude it from the bundle)</b>
      <span class="color-dim">    1 │ import log from </span><span class="color-green">"logger"</span>
      <span class="color-dim">      ╵                 </span><span class="color-green">~~~~~~~~</span>

      <b> &gt; example.js: <span class="color-purple">warning:</span> The "typeof" operator will never evaluate to "null"</b>
      <span class="color-dim">    2 │ log(typeof x == </span><span class="color-green">"null"</span><span class="color-dim">)</span>
      <span class="color-dim">      ╵                 </span><span class="color-green">~~~~~~</span>

      1 warning and 1 error

  - p: >
      Colored output can be force-enabled by setting color to `true`. This is
      useful if you are piping esbuild's stderr output into a TTY yourself:

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --color=true 2> stderr.txt

      js: |
        let js = 'typeof x == "null"'
        require('esbuild').transformSync(js, {
          color: true,
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            Color: api.ColorAlways,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Colored output can also be set to `false` to disable colors.

  - h3: Conditions

  - p: >
      This feature controls how the `exports` field in `package.json` is
      interpreted. Custom conditions can be added using the conditions setting.
      You can specify as many of these as you want and the meaning of these is
      entirely up to package authors. Node has currently only endorsed the
      `development` and `production` custom conditions for recommended use.
      Here is an example of adding the custom conditions `custom1` and `custom2`:

  - example:
      in:
        src/app.js: 'import "pkg"'
        src/node_modules/pkg/package.json: '{ "exports": { "custom1": "./foo.js" } }'
        src/node_modules/pkg/foo.js: 'console.log(123)'

      cli: |
        esbuild src/app.js --bundle --conditions=custom1,custom2

      js: |
        require('esbuild').buildSync({
          entryPoints: ['src/app.js'],
          bundle: true,
          conditions: ['custom1', 'custom2'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"src/app.js"},
            Bundle:      true,
            Conditions:  []string{"custom1", "custom2"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4: How conditions work

  - p: >
      Conditions allow you to redirect the same import path to different file
      locations in different situations. The redirect map containing the
      conditions and paths is stored in the `exports` field in the package's
      `package.json` file. For example, this would remap `require('pkg/foo')`
      to `pkg/required.cjs` and `import 'pkg/foo'` to `pkg/imported.mjs`
      using the `import` and `require` conditions:

  - pre.json: |
      {
        "name": "pkg",
        "exports": {
          "./foo": {
            "import": "./imported.mjs",
            "require": "./required.cjs",
            "default": "./fallback.js"
          }
        }
      }

  - p: >
      Conditions are checked in the order that they appear within the JSON file.
      So the example above behaves sort of like this:

  - pre.js: |
      if (importPath === './foo') {
        if (conditions.has('import')) return './imported.mjs'
        if (conditions.has('require')) return './required.cjs'
        return './fallback.js'
      }

  - p: >
      By default there are five conditions with special behavior that are built
      in to esbuild, and cannot be disabled:

  - ul:
    - >
      `default`
      <p>
      This condition is always active. It is intended to come last and lets you
      provide a fallback for when no other condition applies.
      </p>
    - >
      `import`
      <p>
      This condition is only active when the import path is from an ESM `import`
      statement or `import()` expression. It can be used to provide ESM-specific
      code.
      </p>
    - >
      `require`
      <p>
      This condition is only active when the import path is from a CommonJS
      `require()` call. It can be used to provide CommonJS-specific code.
      </p>
    - >
      `browser`
      <p>
      This condition is only active when esbuild's [platform](#platform) setting
      is set to `browser`. It can be used to provide browser-specific code.
      </p>
    - >
      `node`
      <p>
      This condition is only active when esbuild's [platform](#platform) setting
      is set to `node`. It can be used to provide node-specific code.
      </p>

  - p: >
      Note that when you use the `require` and `import` conditions, _your
      package may end up in the bundle multiple times!_ This is a subtle issue
      that can cause bugs due to duplicate copies of your code's state in
      addition to bloating the resulting bundle. This is commonly known as the
      [dual package hazard](https://nodejs.org/docs/latest/api/packages.html#packages_dual_package_hazard).
      The primary way of avoiding this is to put all of your code in the
      `require` condition and have the `import` condition just be a light
      wrapper that calls `require` on your package and re-exports the package
      using ESM syntax.

  - h3: Footer

  - p: >
      Use this to insert an arbitrary string at the end of generated JavaScript
      and CSS files. This is commonly used to insert comments:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --footer:js=//comment --footer:css=/*comment*/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          footer: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Footer: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This is similar to [banner](#banner) which inserts at the beginning
      instead of the end.

  - h3: Global name

  - p: >
      This option only matters when the [format](#format) setting is `iife`
      (which stands for immediately-invoked function expression). It sets the
      name of the global variable which is used to store the exports from the
      entry point:

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name=xyz

      js: |
        let js = 'module.exports = "test"'
        require('esbuild').transformSync(js, {
          format: 'iife',
          globalName: 'xyz',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: "xyz",
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Specifying the global name with the `iife` format will generate code that
      looks something like this:

  - pre.js: |
      var xyz = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - p: >
      The global name can also be a compound property expression, in which case
      esbuild will generate a global variable with that property. Existing
      global variables that conflict will not be overwritten. This can be used
      to implement "namespacing" where multiple independent scripts add their
      exports onto the same global object. For example:

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name='example.versions["1.0"]'

      js: |
        let js = 'module.exports = "test"'
        require('esbuild').transformSync(js, {
          format: 'iife',
          globalName: 'example.versions["1.0"]',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: `example.versions["1.0"]`,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      The compound global name used above generates code that looks like this:

  - pre.js: |
      var example = example || {};
      example.versions = example.versions || {};
      example.versions["1.0"] = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - h3: Incremental

  - p: >
      You may want to use this API if your use case involves calling esbuild's
      [build API](#build-api) repeatedly with the same options. For example,
      this is useful if you are implementing a file watcher service. Incremental
      builds are more efficient than regular builds because some of the data is
      cached and can be reused if the original files haven't changed since the
      last build. There are currently two forms of caching used by the
      incremental build API:

  - ul:
    - >
      <p>
      Files are stored in memory and are not re-read from the file system if
      the file metadata hasn't changed since the last build. This optimization
      only applies to file system paths. It does not apply to virtual modules
      created by [plugins](/plugins/).
      </p>

    - >
      <p>
      Parsed [ASTs](https://en.wikipedia.org/wiki/Abstract_syntax_tree) are
      stored in memory and re-parsing the AST is avoided if the file contents
      haven't changed since the last build. This optimization applies to
      virtual modules created by plugins in addition to file system modules,
      as long as the virtual module path remains the same.
      </p>

  - p: >
      Here's how to do an incremental build:

  - example:
      in:
        app.js: '1 + 2'

      js: |
        async function example() {
          let result = await require('esbuild').build({
            entryPoints: ['app.js'],
            bundle: true,
            outfile: 'out.js',
            incremental: true,
          })

          // Call "rebuild" as many times as you want
          for (let i = 0; i < 5; i++) {
            let result2 = await result.rebuild()
          }

          // Call "dispose" when you're done to free up resources.
          result.rebuild.dispose()
        }

        example()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
            Incremental: true,
          })
          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          // Call "Rebuild" as many times as you want
          for i := 0; i < 5; i++ {
            result2 := result.Rebuild()
            if len(result2.Errors) > 0 {
              os.Exit(1)
            }
          }
        }

  - h3: JSX factory

  - p: >
      This sets the function that is called for each JSX element. Normally a
      JSX expression such as this:

  - pre.xml: |
      <div>Example text</div>

  - p: >
      is compiled into a function call to `React.createElement` like this:

  - pre.js: |
      React.createElement("div", null, "Example text");

  - p: >
      You can call something other than `React.createElement` by changing the
      JSX factory. For example, to call the function `h` instead (which is
      used by other libraries such as [Preact](https://preactjs.com/)):

  - example:
      cli:
        - $: |
            echo '<div/>' | esbuild --jsx-factory=h --loader=jsx
        - expect: |
            /* @__PURE__ */ h("div", null);

      js:
        - $: |
            require('esbuild').transformSync('<div/>', {
              jsxFactory: 'h',
              loader: 'jsx',
            })
        - expect: |
            {
              code: '/* @__PURE__ */ h("div", null);\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<div/>", api.TransformOptions{
            JSXFactory: "h",
            Loader:     api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Alternatively, if you are using TypeScript, you can just configure JSX
      for TypeScript by adding this to your `tsconfig.json` file and esbuild
      should pick it up automatically without needing to be configured:

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFactory": "h"
        }
      }

  - h3: JSX fragment

  - p: >
      This sets the function that is called for each JSX fragment. Normally a
      JSX fragment expression such as this:

  - pre.xml: |
      <>Stuff</>

  - p: >
      is compiled into a use of the `React.Fragment` component like this:

  - pre.js: |
      React.createElement(React.Fragment, null, "Stuff");

  - p: >
      You can use a component other than `React.Fragment` by changing the
      JSX fragment. For example, to use the component `Fragment` instead
      (which is used by other libraries such as [Preact](https://preactjs.com/)):

  - example:
      cli:
        - $: |
            echo '<>x</>' | esbuild --jsx-fragment=Fragment --loader=jsx
        - expect: |
            /* @__PURE__ */ React.createElement(Fragment, null, "x");

      js:
        - $: |
            require('esbuild').transformSync('<>x</>', {
              jsxFragment: 'Fragment',
              loader: 'jsx',
            })
        - expect: |
            {
              code: '/* @__PURE__ */ React.createElement(Fragment, null, "x");\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<>x</>", api.TransformOptions{
            JSXFragment: "Fragment",
            Loader:      api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Alternatively, if you are using TypeScript, you can just configure JSX
      for TypeScript by adding this to your `tsconfig.json` file and esbuild
      should pick it up automatically without needing to be configured:

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFragmentFactory": "Fragment"
        }
      }

  - h3: Keep names

  - p: >
      In JavaScript the `name` property on functions and classes defaults to a
      nearby identifier in the source code. These syntax forms all set the `name`
      property of the function to `"fn"`:

  - pre.js: |
      function fn() {}
      let fn = function() {};
      fn = function() {};
      let [fn = function() {}] = [];
      let {fn = function() {}} = {};
      [fn = function() {}] = [];
      ({fn = function() {}} = {});

  - p: >
      However, [minification](#minify) renames symbols to reduce code size and
      [bundling](#bundle) sometimes need to rename symbols to avoid collisions.
      That changes value of the `name` property for many of these cases. This
      is usually fine because the `name` property is normally only used for
      debugging. However, some frameworks rely on the `name` property for
      registration and binding purposes. If this is the case, you can enable
      this option to preserve the original `name` values even in minified code:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --minify --keep-names

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          minify: true,
          keepNames: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            KeepNames:         true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Log level

  - p: >
      The log level can be changed to prevent esbuild from printing warning
      and/or error messages to the terminal. The four log levels are `info`
      (show everything), `warning` (show warnings and errors), `error`
      (just show errors), and `silent` (show nothing).

  - p: >
      For example, you can hide all warnings by setting the log level to
      `error`:

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --log-level=error

      js: |
        let js = 'typeof x == "null"'
        require('esbuild').transformSync(js, {
          logLevel: 'error',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            LogLevel: api.LogLevelError,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Log limit

  - p: >
      By default, esbuild stops reporting log messages after 10 messages have
      been reported. This avoids the accidental generation of an overwhelming number
      of log messages, which can easily lock up slower terminal emulators such
      as Windows command prompt. It also avoids accidentally using up the
      whole scroll buffer for terminal emulators with limited scroll buffers.

  - p: >
      The log limit can be changed to another value, and can also be disabled
      completely by setting it to zero. This will show all log messages:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --log-limit=0

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          logLimit: 0,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            LogLimit:    0,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Main fields

  - p: >
      When you import a package in node, the `main` field in that package's
      `package.json` file determines which file is imported (along with
      [a lot of other rules](https://nodejs.org/api/modules.html#modules_all_together)).
      Major JavaScript bundlers including esbuild let you specify additional
      `package.json` fields to try when resolving a package. There are at least
      three such fields commonly in use:

  - ul:
    - >
      `main`
      <p>
      This is [the standard field](https://docs.npmjs.com/files/package.json#main)
      for all packages that are meant to be used with node. The name `main` is
      hard-coded in to node's module resolution logic itself. Because it's
      intended for use with node, it's reasonable to expect that the file path
      in this field is a CommonJS-style module.
      </p>

    - >
      `module`
      <p>
      This field came from [a proposal](https://github.com/dherman/defense-of-dot-js/blob/f31319be735b21739756b87d551f6711bd7aa283/proposal.md)
      for how to integrate ECMAScript modules into node. Because of this, it's
      reasonable to expect that the file path in this field is an
      ECMAScript-style module. This proposal wasn't adopted by node (node uses
      <code>"type": <wbr>"module"</code> instead) but it was adopted by major
      bundlers because ECMAScript-style modules lead to better [tree shaking](#tree-shaking),
      or dead code removal.
      </p>
      <p>
      For package authors: Some packages incorrectly use the `module` field for
      browser-specific code, leaving node-specific code for the `main` field.
      This is probably because node ignores the `module` field and people
      typically only use bundlers for browser-specific code. However, bundling
      node-specific code is valuable too (e.g. it decreases download and boot
      time) and packages that put browser-specific code in `module` prevent
      bundlers from being able to do tree shaking effectively. If you are
      trying to publish browser-specific code in a package, use the `browser`
      field instead.
      </p>

    - >
      `browser`
      <p>
      This field came from [a proposal](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)
      that allows bundlers to replace node-specific files or modules with their
      browser-friendly versions. It lets you specify an alternate
      browser-specific entry point. Note that it is possible for a package to
      use both the `browser` and `module` field together (see the note below).
      </p>

  - p: >
      The default main fields depend on the current [platform](#platform)
      setting and are essentially <code>browser,<wbr>module,<wbr>main</code>
      for the browser and <code>main,<wbr>module</code> for node. These
      defaults should be the most widely compatible with the existing package
      ecosystem. But you can customize them like this if you want to:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --main-fields=module,main

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          mainFields: ['module', 'main'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            MainFields:  []string{"module", "main"},
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      For package authors: If you want to author a package that uses the
      `browser` field in combination with the `module` field to fill out all
      four entries in the full CommonJS-vs-ESM and browser-vs-node compatibility
      matrix, you want to use the expanded form of the `browser` field that is a
      map instead of just a string:

  - pre.json: >
      {
        "main": "./node-cjs.js",
        "module": "./node-esm.js",
        "browser": {
          "./node-cjs.js": "./browser-cjs.js",
          "./node-esm.js": "./browser-esm.js"
        }
      }

  - h3: Metafile

  - p: >
      This option tells esbuild to produce some metadata about the build in
      JSON format. The following example puts the metadata in a file called
      `meta.json`:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --metafile=meta.json --outfile=out.js

      js: |
        const result = require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          metafile: true,
          outfile: 'out.js',
        })
        require('fs').writeFileSync('meta.json',
          JSON.stringify(result.metafile))

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Metafile:    true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          ioutil.WriteFile("meta.json", []byte(result.Metafile), 0644)
        }

  - p: >
      This data can then be analyzed by other tools. For example,
      [bundle buddy](https://www.bundle-buddy.com/esbuild) can consume esbuild's
      metadata format and generates a treemap visualization of the modules in
      your bundle and how much space each one takes up.

  - p: >
      The metadata JSON format looks like this (described using a TypeScript
      interface):

  - pre.ts: |
      interface Metadata {
        inputs: {
          [path: string]: {
            bytes: number
            imports: {
              path: string
              kind: string
            }[]
          }
        }
        outputs: {
          [path: string]: {
            bytes: number
            inputs: {
              [path: string]: {
                bytesInOutput: number
              }
            }
            imports: {
              path: string
              kind: string
            }[]
            exports: string[]
            entryPoint?: string
          }
        }
      }

  - h3: Node paths

  - p: >
      Node's module resolution algorithm supports an environment variable called
      [`NODE_PATH`](https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders)
      that contains a list of global directories to use when resolving import
      paths. These paths are searched for packages in addition to the
      `node_modules` directories in all parent directories. You can pass this
      list of directories to esbuild using an environment variable with the CLI
      and using an array with the JS and Go APIs:

  - example:
      in:
        app.js: 'import {x} from "test"'
        someDir/test.js: 'export let x'

      cli: |
        NODE_PATH=someDir esbuild app.js --bundle --outfile=out.js

      js: |
        require('esbuild').buildSync({
          nodePaths: ['someDir'],
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            NodePaths:   []string{"someDir"},
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If you are using the CLI and want to pass multiple directories using
      `NODE_PATH`, you will have to separate them with `:` on Unix and `;` on
      Windows. This is the same format that Node itself uses.

  - h3: Out extension

  - p: >
      This option lets you customize the file extension of the files that
      esbuild generates to something other than `.js` or `.css`. In particular,
      the `.mjs` and `.cjs` file extensions have special meaning in node (they
      indicate a file in ESM and CommonJS format, respectively). This option is
      useful if you are using esbuild to generate multiple files and you have
      to use the [outdir](#outdir) option instead of the [outfile](#outfile)
      option. You can use it like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outdir=dist --out-extension:.js=.mjs

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'dist',
          outExtension: { '.js': '.mjs' },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "dist",
            OutExtensions: map[string]string{
              ".js": ".mjs",
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Outbase

  - p: >
      If your build contains multiple entry points in separate directories, the
      directory structure will be replicated into the [output directory](#outdir)
      relative to the outbase directory. For example, if there are two entry
      points <code>src/<wbr>pages/<wbr>home/<wbr>index.ts</code> and
      <code>src/<wbr>pages/<wbr>about/<wbr>index.ts</code> and the outbase directory is
      `src`, the output directory will contain <code>pages/<wbr>home/<wbr>index.js</code>
      and <code>pages/<wbr>about/<wbr>index.js</code>. Here's how to use it:

  - example:
      in:
        src/pages/home/index.ts: '1 + 2'
        src/pages/about/index.ts: '3 + 4'

      cli: |
        esbuild src/pages/home/index.ts src/pages/about/index.ts --bundle --outdir=out --outbase=src

      js: |
        require('esbuild').buildSync({
          entryPoints: [
            'src/pages/home/index.ts',
            'src/pages/about/index.ts',
          ],
          bundle: true,
          outdir: 'out',
          outbase: 'src',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{
              "src/pages/home/index.ts",
              "src/pages/about/index.ts",
            },
            Bundle:  true,
            Outdir:  "out",
            Outbase: "src",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If the outbase directory isn't specified, it defaults to the
      [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor)
      directory among all input entry point paths. This is <code>src/<wbr>pages</code>
      in the example above, which means by default the output directory will
      contain <code>home/<wbr>index.js</code> and <code>about/<wbr>index.js</code>
      instead.

  - h3: Preserve symlinks

  - p: >
      This setting mirrors the [`--preserve-symlinks`](https://nodejs.org/api/cli.html#cli_preserve_symlinks)
      setting in node. If you use that setting (or the similar [`resolve.symlinks`](https://webpack.js.org/configuration/resolve/#resolvesymlinks)
      setting in Webpack), you will likely need to enable this setting in
      esbuild too. It can be enabled like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --preserve-symlinks --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          preserveSymlinks: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:      []string{"app.js"},
            Bundle:           true,
            PreserveSymlinks: true,
            Outfile:          "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this setting causes esbuild to determine file identity by the
      original file path (i.e. the path without following symlinks) instead of
      the real file path (i.e. the path after following symlinks). This can be
      beneficial with certain directory structures. Keep in mind that this means
      a file may be given multiple identities if there are multiple symlinks
      pointing to it, which can result in it appearing multiple times in
      generated output files.

  - p: >
      _Note: The term "symlink" means [symbolic link](https://en.wikipedia.org/wiki/Symbolic_link)
      and refers to a file system feature where a path can redirect to another
      path._

  - h3: Public path

  - p: >
      This is useful in combination with the [external file](/content-types/#external-file)
      loader. By default that loader exports the name of the imported file as a
      string using the `default` export. The public path option lets you
      prepend a base path to the exported string of each file loaded by this
      loader:

  - example:
      in:
        app.js: |
          import url from './example.png'
          let image = new Image
          image.src = url
          document.body.appendChild(image)
        example.png: |
          this is some data

      cli: |
        esbuild app.js --bundle --loader:.png=file --public-path=https://www.example.com/v1 --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          loader: { '.png': 'file' },
          publicPath: 'https://www.example.com/v1',
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Outdir:     "out",
            PublicPath: "https://www.example.com/v1",
            Write:      true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Pure

  - p: >
      There is a convention used by various JavaScript tools where a special
      comment containing either `/* @__PURE__ */` or `/* #__PURE__ */` before
      a new or call expression means that that expression can be removed if the
      resulting value is unused. It looks like this:

  - pre.js: |
      let button = /* @__PURE__ */ React.createElement(Button, null);

  - p: >
      This information is used by bundlers such as esbuild during tree shaking
      (a.k.a. dead code removal) to perform fine-grained removal of unused
      imports across module boundaries in situations where the bundler is not
      able to prove by itself that the removal is safe due to the dynamic
      nature of JavaScript code.

  - p: >
      Note that while the comment says "pure", it confusingly does _not_
      indicate that the function being called is pure. For example, it does not
      indicate that it is ok to cache repeated calls to that function. The name
      is essentially just an abstract shorthand for "ok to be removed if unused".

  - p: >
      Some expressions such as JSX and certain built-in globals are automatically
      annotated as `/* @__PURE__ */` in esbuild. You can also configure additional
      globals to be marked `/* @__PURE__ */` as well. For example, you can mark
      the global `console.log` function as such to have it be automatically
      removed from your bundle when the bundle is minified as long as the result
      isn't used.

  - p: >
      It's worth mentioning that the effect of the annotation only extends to
      the call itself, not to the arguments. Arguments with side effects are
      still kept:

  - example:
      cli:
        - $: |
            echo 'console.log("foo:", foo())' | esbuild --pure:console.log
        - expect: |
            /* @__PURE__ */ console.log("foo:", foo());
        - $: |
            echo 'console.log("foo:", foo())' | esbuild --pure:console.log --minify
        - expect: |
            foo();

      js:
        - $: |
            let js = 'console.log("foo:", foo())'
        - $: |
            require('esbuild').transformSync(js, {
              pure: ['console.log'],
            })
        - expect: |
            {
              code: '/* @__PURE__ */ console.log("foo:", foo());\n',
              map: '',
              warnings: []
            }
        - $: |
            require('esbuild').transformSync(js, {
              pure: ['console.log'],
              minify: true,
            })
        - expect: |
            {
              code: 'foo();\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "console.log('foo:', foo())"

          result1 := api.Transform(js, api.TransformOptions{
            Pure: []string{"console.log"},
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Pure:         []string{"console.log"},
            MinifySyntax: true,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - h3: Resolve extensions

  - p: >
      The [resolution algorithm used by node](https://nodejs.org/api/modules.html#modules_file_modules)
      supports implicit file extensions. You can <code>require(<wbr>'./file')</code> and it
      will check for `./file`, `./file.js`, `./file.json`, and `./file.node` in
      that order. Modern bundlers including esbuild extend this concept to other
      file types as well. The full order of implicit file extensions in esbuild
      can be customized using the resolve extensions setting, which defaults to
      <code>.tsx,<wbr>.ts,<wbr>.jsx,<wbr>.js,<wbr>.css,<wbr>.json</code>:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
          esbuild app.js --bundle --resolve-extensions=.ts,.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          resolveExtensions: ['.ts', '.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            Bundle:            true,
            ResolveExtensions: []string{".ts", ".js"},
            Write:             true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Sourcefile

  - p: >
      This option sets the file name when using an input which has no file
      name. This happens when using the transform API and when using the build
      API with stdin. The configured file name is reflected in error messages
      and in source maps. If it's not configured, the file name defaults to
      `<stdin>`. It can be configured like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        cat app.js | esbuild --sourcefile=example.js --sourcemap

      js: |
        let fs = require('fs')
        let js = fs.readFileSync('app.js', 'utf8')

        require('esbuild').transformSync(js, {
          sourcefile: 'example.js',
          sourcemap: 'inline',
        })

      go: |
        package main

        import "fmt"
        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js, err := ioutil.ReadFile("app.js")
          if err != nil {
            panic(err)
          }

          result := api.Transform(string(js),
            api.TransformOptions{
              Sourcefile: "example.js",
              Sourcemap:  api.SourceMapInline,
            })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Sources Content

  - p: >
      [Source maps](#sourcemap) are generated using [version 3](https://sourcemaps.info/spec.html)
      of the source map format, which is by far the most widely-supported
      variant. Each source map will look something like this:

  - pre.json: |
      {
        "version": 3,
        "sources": ["bar.js", "foo.js"],
        "sourcesContent": ["bar()", "foo()\nimport './bar'"],
        "mappings": ";AAAA;;;ACAA;",
        "names": []
      }

  - p: >
      The `sourcesContent` field is an optional field that contains all of the
      original source code. This is helpful for debugging because it means the
      original source code will be available in the debugger.

  - p: >
      However, it's not needed in some scenarios. For example, if you are just
      using source maps in production to generate stack traces that contain the
      original file name, you don't need the original source code because there
      is no debugger involved. In that case it can be desirable to omit the
      `sourcesContent` field to make the source map smaller:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild --bundle app.js --sourcemap --sources-content=false

      js: |
        require('esbuild').buildSync({
          bundle: true,
          entryPoints: ['app.js'],
          sourcemap: true,
          sourcesContent: false,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Bundle:         true,
            EntryPoints:    []string{"app.js"},
            Sourcemap:      api.SourceMapInline,
            SourcesContent: api.SourcesContentExclude,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Stdin

  - p: >
      Normally the build API call takes one or more file names as input.
      However, this option can be used to run a build without a module existing
      on the file system at all. It's called "stdin" because it corresponds to
      piping a file to stdin on the command line.

  - p: >
      In addition to specifying the contents of the stdin file, you can
      optionally also specify the resolve directory (used to determine where
      relative imports are located), the [sourcefile](#sourcefile) (the file
      name to use in error messages and source maps), and the [loader](#loader)
      (which determines how the file contents are interpreted). The CLI doesn't
      have a way to specify the resolve directory. Instead, it's automatically
      set to the current working directory.

  - p: >
      Here's how to use this feature:

  - example:
      in:
        another-file.js: 'export let foo = 123'

      cli: |
        echo 'export * from "./another-file"' | esbuild --bundle --sourcefile=imaginary-file.js --loader=ts --format=cjs

      js: |
        let result = require('esbuild').buildSync({
          stdin: {
            contents: `export * from "./another-file"`,

            // These are all optional:
            resolveDir: require('path').join(__dirname, 'src'),
            sourcefile: 'imaginary-file.js',
            loader: 'ts',
          },
          format: 'cjs',
          write: false,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Stdin: &api.StdinOptions{
              Contents: "export * from './another-file'",

              // These are all optional:
              ResolveDir: "./src",
              Sourcefile: "imaginary-file.js",
              Loader:     api.LoaderTS,
            },
            Format: api.FormatCommonJS,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Tree shaking

  - p: >
      Tree shaking is the term the JavaScript community uses for dead code
      elimination, a common compiler optimization that automatically removes
      unreachable code. Note that tree shaking in esbuild is always enabled
      during bundling and can't be turned off, since trimming unused code
      makes the resulting file smaller without changing observable behavior.

  - p: >
      Tree shaking is easiest to explain with an example. Consider the following
      file. There is one used function and one unused function:

  - pre.js: |
      // input.js
      function one() {
        console.log('one')
      }
      function two() {
        console.log('two')
      }
      one()

  - p: >
      If you bundle this file with <code>esbuild <wbr>--bundle <wbr>input.js <wbr>--outfile=<wbr>output.js</code>,
      the unused function will automatically be discarded leaving you with the
      following output:

  - pre.js: |
      // input.js
      function one() {
        console.log("one");
      }
      one();

  - p: >
      This even works if we split our functions off into a separate library
      file and import them using an `import` statement:

  - pre.js: |
      // lib.js
      export function one() {
        console.log('one')
      }
      export function two() {
        console.log('two')
      }

  - pre.js: |
      // input.js
      import * as lib from './lib.js'
      lib.one()

  - p: >
      If you bundle this file with <code>esbuild <wbr>--bundle <wbr>input.js <wbr>--outfile=<wbr>output.js</code>,
      the unused function and unused import will still be automatically
      discarded leaving you with the following output:

  - pre.js: |
      // lib.js
      function one() {
        console.log("one");
      }

      // input.js
      one();

  - p: >
      This way esbuild will only bundle the parts of your libraries that you
      actually use, which can sometimes be a substantial size savings. Note
      that esbuild's tree shaking implementation relies on the use of ECMAScript
      module `import` and `export` statements. It does not work with CommonJS
      modules. Many libraries on npm include both formats and esbuild tries to
      pick the format that works with tree shaking by default. You can
      customize which format esbuild picks using the [main fields](#main-fields)
      option.

  - h4: Manual tree shaking annotations

  - p: >
      Since JavaScript is a dynamic language, identifying
      unused code is sometimes very difficult for a compiler, so the community
      has developed certain annotations to help tell compilers what code should
      be considered unused. Currently there are two forms of tree-shaking
      annotations that esbuild supports:

  - ul:
    - >
      <p>
      Inline `/* @__PURE__ */` comments before function calls tell esbuild that
      the function call can be removed if the resulting value isn't used. See
      the [pure](#pure) API option for more information.
      </p>

    - >
      <p>
      The `sideEffects` field in `package.json` can be used to tell esbuild
      which files in your package can be removed if all imports from that
      file end up being unused. This is a convention from Webpack and many
      libraries published to npm already have this field in their package
      definition. You can learn more about this field in
      [Webpack's documentation](https://webpack.js.org/guides/tree-shaking/)
      for this field.
      </p>

  - p: >
      These annotations can be problematic because the compiler depends
      completely on developers for accuracy, and developers occasionally
      publish packages with incorrect annotations. The `sideEffects` field is
      particularly error-prone for developers because by default it causes all
      files in your package to be considered dead code if no imports are used.
      If you add a new file containing side effects and forget to update that
      field, your package will likely break when people try to bundle it.

  - p: >
      This is why esbuild includes a way to ignore tree-shaking annotations.
      You should only enable this if you encounter a problem where the bundle
      is broken because necessary code was unexpectedly removed from the bundle:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
          esbuild app.js --bundle --tree-shaking=ignore-annotations

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          treeShaking: 'ignore-annotations',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            TreeShaking: api.TreeShakingIgnoreAnnotations,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this means esbuild will no longer respect `/* @__PURE__ */`
      comments or the `sideEffects` field. It will still do automatic tree
      shaking of unused imports, however, since that doesn't rely on
      annotations from developers. Ideally this flag is only a temporary
      workaround. You should report these issues to the maintainer of the
      package to get them fixed since they indicate a problem with the package
      and they will likely trip up other people too.

  - h3: Tsconfig

  - p: >
      Normally the [build API](#build-api) automatically discovers `tsconfig.json`
      files and reads their contents during a build. However, you can also
      configure a custom `tsconfig.json` file to use instead. This can be
      useful if you need to do multiple builds of the same code with different
      settings:

  - example:
      in:
        app.ts: '1 + 2'
        custom-tsconfig.json: '{}'

      cli: |
          esbuild app.ts --bundle --tsconfig=custom-tsconfig.json

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          bundle: true,
          tsconfig: 'custom-tsconfig.json',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Bundle:      true,
            Tsconfig:    "custom-tsconfig.json",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Tsconfig raw

  - p: >
      This option can be used to pass your `tsconfig.json` file to the
      [transform API](#transform-api), which doesn't access the file system.
      Using it looks like this:

  - example:
      cli: |
          echo 'class Foo { foo }' | esbuild --loader=ts --tsconfig-raw='{"compilerOptions":{"useDefineForClassFields":true}}'

      js: |
        let ts = 'class Foo { foo }'
        require('esbuild').transformSync(ts, {
          loader: 'ts',
          tsconfigRaw: `{
            "compilerOptions": {
              "useDefineForClassFields": true,
            },
          }`,
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          ts := "class Foo { foo }"

          result := api.Transform(ts, api.TransformOptions{
            Loader: api.LoaderTS,
            TsconfigRaw: `{
              "compilerOptions": {
                "useDefineForClassFields": true,
              },
            }`,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Working Directory

  - p: >
      This API option lets you specify the working directory to use for the
      build. It normally defaults to the [current working directory](https://en.wikipedia.org/wiki/Working_directory)
      of the process you are using to call esbuild's API. The working directory
      is used by esbuild for a few different things including resolving relative
      paths given as API options to absolute paths and pretty-printing absolute
      paths as relative paths in log messages. Here is how to override it:

  - example:
      in:
        file.js: 'export let foo = 123'

      js: |
        require('esbuild').buildSync({
          entryPoints: ['file.js'],
          absWorkingDir: process.cwd(),
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "log"
        import "os"

        func main() {
          cwd, err := os.Getwd()
          if err != nil {
            log.Fatal(err)
          }

          result := api.Build(api.BuildOptions{
            EntryPoints:   []string{"file.js"},
            AbsWorkingDir: cwd,
            Outfile:       "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h2: JS-specific details

  - p: >
      Because JavaScript is single-threaded, there are several different ways
      to invoke the API with different performance and convenience tradeoffs.
      It's important to be aware of the differences to pick the correct one for
      your situation.

  - p: >
      First there is the synchronous API. This is the most convenient option
      because single-threaded JavaScript code has the cleanest syntax. It's
      also optimal performance-wise if all you need to do is run esbuild and
      then exit. However, it blocks the main thread so you do not want to use
      it if you have other work to perform in the meantime. This is also the
      only option that cannot use plugins (since plugins are asynchronous).
      It looks like this:

  - pre.js: |
      let esbuild = require('esbuild')
      let result1 = esbuild.transformSync(code, options)
      let result2 = esbuild.buildSync(options)

  - p: >
      Then there is the asynchronous API. Each call returns a promise instead
      of completing immediately. Under the hood, the esbuild binary is spawned
      as a single child process shared between all calls in the host process.
      The host communicates with the child over the stdin, stdout, and stderr
      pipes using a custom binary protocol. This is ideal if you only need to
      run esbuild once but you need to do other work in the background. It also
      allows you to run many simultaneous esbuild API calls concurrently which
      are then spread across all available cores for maximum performance. Using
      it looks something like this:

  - pre.js: |
      let esbuild = require('esbuild')
      esbuild.transform(code, options).then(result => { ... })
      esbuild.build(options).then(result => { ... })

  - h3: Running in the browser
  - p: >
      The esbuild API can also run in the browser using WebAssembly in a Web
      Worker. To take advantage of this you will need to install the
      `esbuild-wasm` package instead of the `esbuild` package:

  - pre: |
      npm install esbuild-wasm

  - p: >
      The API for the browser is similar to the API for node except that you
      need to call `initialize()` first, and you need to pass the URL of
      the WebAssembly binary. The synchronous versions of the API are also
      not available. Assuming you are using a bundler, that would look
      something like this:

  - pre.js: |
      let esbuild = require('esbuild-wasm')

      esbuild.initialize({
        wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
      }).then(() => {
        esbuild.transform(code, options).then(result => { ... })
        esbuild.build(options).then(result => { ... })
      })

  - p: >
      If you're already running this code from a worker and don't want
      `initialize` to create another worker, you can pass <code>worker: <wbr>false</code>
      to it. Then it will create a WebAssembly module in the same thread
      as the thread that calls `initialize`.

  - p: >
      You can also use esbuild's API as a script tag in a HTML file without
      needing to use a bundler by injecting the `lib/browser.min.js` file. In
      this case the API creates a global called `esbuild` that holds the API
      object:

  - pre.html: |
      <script src="./node_modules/esbuild-wasm/lib/browser.min.js"></script>
      <script>
        esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        }).then(() => { ... })
      </script>

  - p: >
      If you need to use this API with ECMAScript modules, you should import
      the `esm/browser.min.js` file instead:

  - pre.html: |
      <script type="module">
        import * as esbuild from './node_modules/esbuild-wasm/esm/browser.min.js'

        esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        }).then(() => { ... })
      </script>
