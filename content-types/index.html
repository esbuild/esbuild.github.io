<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf8">
    <title>esbuild - Content Types</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <meta property="og:title" content="esbuild - Content Types"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://esbuild.github.io/index.png"/>
    <meta property="twitter:card" content="summary_large_image"/>
    <meta property="twitter:title" content="esbuild - Content Types"/>
    <meta property="twitter:image" content="https://esbuild.github.io/index.png"/>
    <link rel="stylesheet" href="/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <script>
      function os() {
        return navigator.platform === 'Win32' ? 'windows' : 'unix'
      }
      try {
        document.body.dataset.mode3 = localStorage.getItem('mode3') || 'cli'
        document.body.dataset.mode2 = localStorage.getItem('mode2') || 'js'
        document.body.dataset.os2 = localStorage.getItem('os2') || os()
        document.body.dataset.theme = localStorage.getItem('theme')
      } catch (e) {
        document.body.dataset.mode3 = 'cli'
        document.body.dataset.mode2 = 'js'
        document.body.dataset.os2 = os()
        document.body.dataset.theme = null
      }
      document.body.classList.add('has-js')
    </script>
    <script src="/script.js" defer></script>
    <div id="menubar">
      <a id="menutoggle" href="javascript:void 0" aria-label="Toggle the menu">
        <svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
          <rect x="15" y="18" width="20" height="2" stroke-width="0"></rect>
          <rect x="15" y="24" width="20" height="2" stroke-width="0"></rect>
          <rect x="15" y="30" width="20" height="2" stroke-width="0"></rect>
        </svg>
      </a>
    </div>
    <nav>
      <div id="shadow"></div>
      <div id="menu">
        <a href="/" class="logo">esbuild</a>
        <ul>
          <li>
            <a href="/getting-started/">Getting Started</a>
            <ul class="h2">
              <li><a href="/getting-started/#install-esbuild">Install esbuild</a></li>
              <li><a href="/getting-started/#your-first-bundle">Your first bundle</a></li>
              <li><a href="/getting-started/#build-scripts">Build scripts</a></li>
              <li><a href="/getting-started/#bundling-for-the-browser">Bundling for the browser</a></li>
              <li><a href="/getting-started/#bundling-for-node">Bundling for node</a></li>
              <li><a href="/getting-started/#other-ways-to-install">Other ways to install</a></li>
            </ul>
          </li>
          <li>
            <a href="/api/">API</a>
            <ul class="h2">
              <li><a href="/api/#transform-api">Transform API</a></li>
              <li><a href="/api/#build-api">Build API</a></li>
              <li><a href="/api/#simple-options">Simple options</a></li>
              <li><a href="/api/#advanced-options">Advanced options</a></li>
              <li><a href="/api/#js-specific-details">JS-specific details</a></li>
            </ul>
          </li>
          <li>
            <a href="/content-types/">Content Types</a>
            <ul class="h2">
              <li id="nav-javascript">
                <a href="#javascript">JavaScript</a>
                <ul class="h3">
                  <li id="nav-javascript-caveats"><a href="#javascript-caveats">JavaScript caveats</a></li>
                </ul>
              </li>
              <li id="nav-typescript">
                <a href="#typescript">TypeScript</a>
                <ul class="h3">
                  <li id="nav-typescript-caveats"><a href="#typescript-caveats">TypeScript caveats</a></li>
                </ul>
              </li>
              <li id="nav-jsx">
                <a href="#jsx">JSX</a>
                <ul class="h3">
                  <li id="nav-auto-import-for-jsx"><a href="#auto-import-for-jsx">Auto-import for JSX</a></li>
                  <li id="nav-using-jsx-without-react"><a href="#using-jsx-without-react">Using JSX without React</a></li>
                </ul>
              </li>
              <li id="nav-json"><a href="#json">JSON</a></li>
              <li id="nav-css"><a href="#css">CSS</a></li>
              <li id="nav-text"><a href="#text">Text</a></li>
              <li id="nav-binary"><a href="#binary">Binary</a></li>
              <li id="nav-base64"><a href="#base64">Base64</a></li>
              <li id="nav-data-url"><a href="#data-url">Data URL</a></li>
              <li id="nav-external-file"><a href="#external-file">External file</a></li>
            </ul>
          </li>
          <li>
            <a href="/plugins/">Plugins</a>
            <ul class="h2">
              <li><a href="/plugins/#finding-plugins">Finding plugins</a></li>
              <li><a href="/plugins/#using-plugins">Using plugins</a></li>
              <li><a href="/plugins/#concepts">Concepts</a></li>
              <li><a href="/plugins/#resolve-callbacks">Resolve callbacks</a></li>
              <li><a href="/plugins/#load-callbacks">Load callbacks</a></li>
              <li><a href="/plugins/#build-options">Accessing build options</a></li>
              <li><a href="/plugins/#example-plugins">Example plugins</a></li>
              <li><a href="/plugins/#plugin-api-limitations">Plugin API limitations</a></li>
            </ul>
          </li>
          <li><a href="/faq/">FAQ</a></li>
        </ul>
        <div id="icons">
          <a href="https://github.com/evanw/esbuild" aria-label="View this project on GitHub">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25">
              <path fill-rule="evenodd" stroke-width="0" d="M13 5a8 8 0 00-2.53 15.59c.4.07.55-.17.55
                -.38l-.01-1.49c-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52
                -.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78
                -.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2
                .82a7.42 7.42 0 014 0c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27
                .82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48l-.01 2.2c0 .21.15.46.55.38A
                8.01 8.01 0 0021 13a8 8 0 00-8-8z"></path>
            </svg>
          </a><a href="javascript:void 0" id="theme" aria-label="Toggle dark mode">
            <svg id="theme-light" width="25" height="25" xmlns="http://www.w3.org/2000/svg">
              <path d="M13.5 4v3m9.5 6.5h-3M13.5 23v-3M7 13.5H4M9 9L7 7m13 0l-2 2m2 11l-2-2M7 20l2-2"></path>
              <circle cx="13.5" cy="13.5" r="4.5" stroke-width="0"></circle>
            </svg>
            <svg id="theme-dark" width="25" height="25" xmlns="http://www.w3.org/2000/svg">
              <path d="M10.1 6.6a8.08 8.08 0 00.24 11.06 8.08 8.08 0 0011.06.24c-6.46.9-12.2-4.84-11.3-11.3z" stroke-width="0"></path>
            </svg>
          </a>
        </div>
      </div>
    </nav>

    <main>
      <h1>Content Types</h1>
      <p>All of the built-in content types are listed below. Each content type has an associated &quot;loader&quot; which tells esbuild how to interpret the file contents. Some file extensions already have a loader configured for them by default, although the defaults can be overridden.</p>
      <h2 id="javascript">
        <a class="permalink" href="#javascript">#</a>
        JavaScript
      </h2>
      <p>Loader: <code>js</code></p>
      <p>This loader is enabled by default for <code>.js</code>, <code>.cjs</code>, and <code>.mjs</code> files. The <code>.cjs</code> extension is used by node for CommonJS modules and the <code>.mjs</code> extension is used by node for ECMAScript modules, although esbuild doesn't make a distinction between the two.</p>
      <p>All modern JavaScript syntax is supported by esbuild. Newer syntax may not be supported by older browsers, however, so you may want to configure the <a href="/api/#target">target</a> option to tell esbuild to convert newer syntax to older syntax as appropriate.</p>
      <p>These syntax features are always transformed for older browsers:</p>
      <table>
      <thead>
      <tr>
      <th>Syntax transform</th>
      <th>Language version</th>
      <th>Example</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td><a href="https://github.com/tc39/proposal-trailing-function-commas">Trailing commas in function parameter lists and calls</a></td>
      <td><code>es2017</code></td>
      <td><code>foo(a, b, )</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-numeric-separator">Numeric separators</a></td>
      <td><code>esnext</code></td>
      <td><code>1_000_000</code></td>
      </tr>
      </tbody>
      </table>
      <p>These syntax features are conditionally transformed for older browsers depending on the configured language target:</p>
      <table>
      <thead>
      <tr>
      <th>Syntax transform</th>
      <th>Transformed when <code>--target</code> is below</th>
      <th>Example</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td><a href="https://github.com/tc39/proposal-exponentiation-operator">Exponentiation operator</a></td>
      <td><code>es2016</code></td>
      <td><code>a ** b</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/ecmascript-asyncawait">Async functions</a></td>
      <td><code>es2017</code></td>
      <td><code>async () =&gt; {}</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-object-rest-spread">Spread properties</a></td>
      <td><code>es2018</code></td>
      <td><code>let x = {...y}</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-object-rest-spread">Rest properties</a></td>
      <td><code>es2018</code></td>
      <td><code>let {...x} = y</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-optional-catch-binding">Optional catch binding</a></td>
      <td><code>es2019</code></td>
      <td><code>try {} catch {}</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-optional-chaining">Optional chaining</a></td>
      <td><code>es2020</code></td>
      <td><code>a?.b</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-nullish-coalescing">Nullish coalescing</a></td>
      <td><code>es2020</code></td>
      <td><code>a ?? b</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-import-meta"><code>import.meta</code></a></td>
      <td><code>es2020</code></td>
      <td><code>import.meta</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-class-fields">Class instance fields</a></td>
      <td><code>esnext</code></td>
      <td><code>class { x }</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-static-class-features">Static class fields</a></td>
      <td><code>esnext</code></td>
      <td><code>class { static x }</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-private-methods">Private instance methods</a></td>
      <td><code>esnext</code></td>
      <td><code>class { #x() {} }</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-class-fields">Private instance fields</a></td>
      <td><code>esnext</code></td>
      <td><code>class { #x }</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-static-class-features">Private static methods</a></td>
      <td><code>esnext</code></td>
      <td><code>class { static #x() {} }</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-static-class-features">Private static fields</a></td>
      <td><code>esnext</code></td>
      <td><code>class { static #x }</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-logical-assignment">Logical assignment operators</a></td>
      <td><code>esnext</code></td>
      <td><code>a ??= b</code></td>
      </tr>
      </tbody>
      </table>
      <p>These syntax features are currently always passed through un-transformed:</p>
      <table>
      <thead>
      <tr>
      <th>Syntax transform</th>
      <th>Unsupported when <code>--target</code> is below</th>
      <th>Example</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td><a href="https://github.com/tc39/proposal-async-iteration">Asynchronous iteration</a></td>
      <td><code>es2018</code></td>
      <td><code>for await (let x of y) {}</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-async-iteration">Async generators</a></td>
      <td><code>es2018</code></td>
      <td><code>async function* foo() {}</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-bigint">BigInt</a></td>
      <td><code>es2020</code></td>
      <td><code>123n</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-hashbang">Hashbang grammar</a></td>
      <td><code>esnext</code></td>
      <td><code>#!/usr/bin/env node</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-top-level-await">Top-level await</a></td>
      <td><code>esnext</code></td>
      <td><code>await import(x)</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/tc39/proposal-private-fields-in-in">Ergonomic brand checks</a></td>
      <td><code>esnext</code></td>
      <td><code>#foo in bar</code></td>
      </tr>
      <tr>
      <td><a href="https://github.com/bmeck/proposal-arbitrary-module-namespace-identifiers">Arbitrary module namespace identifiers</a></td>
      <td><code>esnext</code></td>
      <td><code>export {foo as 'f o o'}</code></td>
      </tr>
      </tbody>
      </table>
      <p>See also <a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">the list of finished ECMAScript proposals</a> and <a href="https://github.com/tc39/proposals/blob/master/README.md">the list of active ECMAScript proposals</a>. Note that while transforming code containing top-level await is supported, bundling code containing top-level await is only supported when the <a href="/api/#format">output format</a> is set to <a href="/api/#format-esm"><code>esm</code></a>.</p>
      <h3 id="javascript-caveats" data-h2="javascript">
        <a class="permalink" href="#javascript-caveats">#</a>
        JavaScript caveats
      </h3>
      <p>You should keep the following things in mind when using JavaScript with esbuild:</p>
      <h4 id="es5" data-h2="javascript" data-h3="javascript-caveats">
        <a class="permalink" href="#es5">#</a>
        ES5 is not supported well
      </h4>
      <p>Transforming ES6+ syntax to ES5 is not supported yet. However, if you're using esbuild to transform ES5 code, you should still set the <a href="/api/#target">target</a> to <code>es5</code>. This prevents esbuild from introducing ES6 syntax into your ES5 code. For example, without this flag the object literal <code>{x: x}</code> will become <code>{x}</code> and the string <code>&quot;a\nb&quot;</code> will become a multi-line template literal when minifying. Both of these substitutions are done because the resulting code is shorter, but the substitutions will not be performed if the <a href="/api/#target">target</a> is <code>es5</code>.</p>
      <h4 id="private-member-performance" data-h2="javascript" data-h3="javascript-caveats">
        <a class="permalink" href="#private-member-performance">#</a>
        Private member performance
      </h4>
      <p>The private member transform (for the <code>#name</code> syntax) uses <code>WeakMap</code> and <code>WeakSet</code> to preserve the privacy properties of this feature. This is similar to the corresponding transforms in the Babel and TypeScript compilers. Most modern JavaScript engines (V8, JavaScriptCore, and SpiderMonkey but not ChakraCore) may not have good performance characteristics for large <code>WeakMap</code> and <code>WeakSet</code> objects.</p>
      <p>Creating many instances of classes with private fields or private methods with this syntax transform active may cause a lot of overhead for the garbage collector. This is because modern engines (other than ChakraCore) store weak values in an actual map object instead of as hidden properties on the keys themselves, and large map objects can cause performance issues with garbage collection. See <a href="https://github.com/tc39/ecma262/issues/1657#issuecomment-518916579">this reference</a> for more information.</p>
      <h4 id="direct-eval" data-h2="javascript" data-h3="javascript-caveats">
        <a class="permalink" href="#direct-eval">#</a>
        Avoid direct <code>eval</code> when bundling
      </h4>
      <p>Although the expression <code>eval(x)</code> looks like a normal function call, it actually takes on special behavior in JavaScript. Using <code>eval</code> in this way means that the evaluated code stored in <code>x</code> can reference any variable in any containing scope by name. For example, the code <code>let y = <wbr>123; <wbr>return <wbr>eval('y')</code> will return <code>123</code>.</p>
      <p>This is called &quot;direct eval&quot; and is problematic when bundling your code for many reasons:</p>
      <ul><li><p> Modern bundlers contain an optimization called &quot;scope hoisting&quot; that merges all bundled files into a single file and renames variables to avoid name collisions. However, this means code evaluated by direct <code>eval</code> can read and write variables in any file in the bundle! This is a correctness issue because the evaluated code may try to access a global variable but may accidentally access a private variable with the same name from another file instead. It can potentially even be a security issue if a private variable in another file has sensitive data. </p></li><li><p> The evaluated code may not work correctly when it references variables imported using an <code>import</code> statement. Imported variables are live bindings to variables in another file. They are not copies of those variables. So when esbuild bundles your code, your imports are replaced with a direct reference to the variable in the imported file. But that variable may have a different name, in which case the code evaluated by direct <code>eval</code> will be unable to reference it by the expected name. </p></li><li><p> Using direct <code>eval</code> forces esbuild to deoptimize all of the code in all of the scopes containing calls to direct <code>eval</code>. For correctness, it must assume that the evaluated code might need to access any of the other code in the file reachable from that <code>eval</code> call. This means none of that code will be eliminated as dead code and none of that code will be minified. </p></li><li><p> Because the code evaluated by the direct <code>eval</code> could need to reference any reachable variable by name, esbuild is prevented from renaming all of the variables reachable by the evaluated code. This means it can't rename variables to avoid name collisions with other variables in the bundle. So the direct <code>eval</code> causes esbuild to wrap the file in a CommonJS closure, which avoids name collisions by introducing a new scope instead. However, this makes the generated code bigger and slower because exported variables use run-time dynamic binding instead of compile-time static binding. </p></li></ul>
      <p>Luckily it is usually easy to avoid using direct <code>eval</code>. There are two commonly-used alternatives that avoid all of the drawbacks mentioned above:</p>
      <ul><li><code>(0, eval)('x')</code> <p> This is known as &quot;indirect eval&quot; because <code>eval</code> is not being called directly, and so does not trigger the grammatical special case for direct eval in the JavaScript VM. You can call indirect eval using any syntax at all except for an expression of the exact form <code>eval('x')</code>. For example, <code>var eval2 = <wbr>eval; <wbr>eval2('x')</code> and <code>[eval][0]('x')</code> and <code>window.<wbr>eval('x')</code> are all indirect eval calls. When you use indirect eval, the code is evaluated in the global scope instead of in the inline scope of the caller. </p></li><li><code>new Function('x')</code> <p> This constructs a new function object at run-time. It is as if you wrote <code>function() <wbr>{ x }</code> in the global scope except that <code>x</code> can be an arbitrary string of code. This form is sometimes convenient because you can add arguments to the function, and use those arguments to expose variables to the evaluated code. For example, <code>(new Function('env', <wbr>'x'))(<wbr>someEnv)</code> is as if you wrote <code>(function(env) <wbr>{ x })(<wbr>someEnv)</code>. This is often a sufficient alternative for direct <code>eval</code> when the evaluated code needs to access local variables because you can pass the local variables in as arguments. </p></li></ul>
      <h2 id="typescript">
        <a class="permalink" href="#typescript">#</a>
        TypeScript
      </h2>
      <p>Loader: <code>ts</code> or <code>tsx</code></p>
      <p>This loader is enabled by default for <code>.ts</code> and <code>.tsx</code> files, which means esbuild has built-in support for parsing TypeScript syntax and discarding the type annotations. However, esbuild <em>does not</em> do any type checking so you will still need to run <code>tsc -noEmit</code> in parallel with esbuild to check types. This is not something esbuild does itself.</p>
      <p>TypeScript type declarations like these are parsed and ignored (a non-exhaustive list):</p>
      <table>
      <thead>
      <tr>
      <th>Syntax feature</th>
      <th>Example</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>Interface declarations</td>
      <td><code>interface Foo {}</code></td>
      </tr>
      <tr>
      <td>Type declarations</td>
      <td><code>type Foo = number</code></td>
      </tr>
      <tr>
      <td>Function declarations</td>
      <td><code>function foo(): void;</code></td>
      </tr>
      <tr>
      <td>Ambient declarations</td>
      <td><code>declare module 'foo' {}</code></td>
      </tr>
      <tr>
      <td>Type-only imports</td>
      <td><code>import type {Type} from 'foo'</code></td>
      </tr>
      <tr>
      <td>Type-only exports</td>
      <td><code>export type {Type} from 'foo'</code></td>
      </tr>
      </tbody>
      </table>
      <p>TypeScript-only syntax extensions are supported, and are always converted to JavaScript (a non-exhaustive list):</p>
      <table>
      <thead>
      <tr>
      <th>Syntax feature</th>
      <th>Example</th>
      <th>Notes</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>Namespaces</td>
      <td><code>namespace Foo {}</code></td>
      <td></td>
      </tr>
      <tr>
      <td>Enums</td>
      <td><code>enum Foo { A, B }</code></td>
      <td></td>
      </tr>
      <tr>
      <td>Const enums</td>
      <td><code>const enum Foo { A, B }</code></td>
      <td>Behaves the same as regular enums</td>
      </tr>
      <tr>
      <td>Generic type parameters</td>
      <td><code>&lt;T&gt;(a: T): T =&gt; a</code></td>
      <td>Not available with the <code>tsx</code> loader</td>
      </tr>
      <tr>
      <td>JSX with types</td>
      <td><code>&lt;Element&lt;T&gt;/&gt;</code></td>
      <td></td>
      </tr>
      <tr>
      <td>Type casts</td>
      <td><code>a as B</code> and <code>&lt;B&gt;a</code></td>
      <td></td>
      </tr>
      <tr>
      <td>Type imports</td>
      <td><code>import {Type} from 'foo'</code></td>
      <td>Handled by removing all unused imports</td>
      </tr>
      <tr>
      <td>Type exports</td>
      <td><code>export {Type} from 'foo'</code></td>
      <td>Handled by ignoring missing exports in TypeScript files</td>
      </tr>
      <tr>
      <td>Experimental decorators</td>
      <td><code>@sealed class Foo {}</code></td>
      <td>The <code>emitDecoratorMetadata</code> flag is not supported</td>
      </tr>
      </tbody>
      </table>
      <h3 id="typescript-caveats" data-h2="typescript">
        <a class="permalink" href="#typescript-caveats">#</a>
        TypeScript caveats
      </h3>
      <p>You should keep the following things in mind when using TypeScript with esbuild (in addition to the <a href="#javascript-caveats">JavaScript caveats</a>):</p>
      <h4 id="isolated-modules" data-h2="typescript" data-h3="typescript-caveats">
        <a class="permalink" href="#isolated-modules">#</a>
        Files are compiled independently
      </h4>
      <p>Even when transpiling a single module, the TypeScript compiler actually still parses imported files so it can tell whether an imported name is a type or a value. However, tools like esbuild and Babel (and the TypeScript compiler's <code>transpileModule</code> API) compile each file in isolation so they can't tell if an imported name is a type or a value.</p>
      <p>Because of this, you should enable the <a href="https://www.typescriptlang.org/tsconfig#isolatedModules"><code>isolatedModules</code></a> TypeScript configuration option if you use TypeScript with esbuild. This option prevents you from using features which could cause mis-compilation in environments like esbuild where each file is compiled independently without tracing type references across files. For example, it prevents you from re-exporting types from another module using <code>export <wbr>{T} <wbr>from <wbr>'./types'</code> (you need to use <code>export <wbr>type <wbr>{T} <wbr>from <wbr>'./types'</code> instead).</p>
      <h4 id="es-module-interop" data-h2="typescript" data-h3="typescript-caveats">
        <a class="permalink" href="#es-module-interop">#</a>
        Imports follow ECMAScript module behavior
      </h4>
      <p>For historical reasons, the TypeScript compiler compiles ESM (ECMAScript module) syntax to CommonJS syntax by default. For example, <code>import *<wbr> as foo<wbr> from 'foo'</code> is compiled to <code>const foo =<wbr> require('foo')</code>. Presumably this happened because ECMAScript modules were still a proposal when TypeScript adopted the syntax. However, this is legacy behavior that doesn't match how this syntax behaves on real platforms such as node. For example, the <code>require</code> function can return any JavaScript value including a string but the <code>import * as</code> syntax always results in an object and cannot be a string.</p>
      <p>To avoid problems due to this legacy feature, you should enable the <a href="https://www.typescriptlang.org/tsconfig#esModuleInterop"><code>esModuleInterop</code></a> TypeScript configuration option if you use TypeScript with esbuild. Enabling it disables this legacy behavior and makes TypeScript's type system compatible with ESM. This option is not enabled by default because it would be a breaking change for existing TypeScript projects, but Microsoft <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#support-for-import-d-from-cjs-from-commonjs-modules-with---esmoduleinterop">highly recommends applying it both to new and existing projects</a> (and then updating your code) for better compatibility with the rest of the ecosystem.</p>
      <p>Specifically this means that importing a non-object value from a CommonJS module with ESM import syntax must be done using a default import instead of using <code>import * as</code>. So if a CommonJS module exports a function via <code>module.<wbr>exports =<wbr> fn</code>, you need to use <code>import <wbr>fn <wbr>from <wbr>'path'</code> instead of <code>import *<wbr> as<wbr> <wbr>fn <wbr>from <wbr>'path'</code>.</p>
      <h4 id="no-type-system" data-h2="typescript" data-h3="typescript-caveats">
        <a class="permalink" href="#no-type-system">#</a>
        Features that need a type system are not supported
      </h4>
      <p>TypeScript types are treated as comments and are ignored by esbuild, so TypeScript is treated as &quot;type-checked JavaScript.&quot; The interpretation of the type annotations is up to the TypeScript type checker, which you should be running in addition to esbuild if you're using TypeScript. This is the same compilation strategy that Babel's TypeScript implementation uses. However, it means that some TypeScript compilation features which require type interpretation to work do not work with esbuild.</p>
      <p>Specifically:</p>
      <ul><li><p> The <a href="https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata"><code>emitDecoratorMetadata</code></a> TypeScript configuration option is not supported. This feature passes a JavaScript representation of the corresponding TypeScript type to the attached decorator function. Since esbuild does not replicate TypeScript's type system, it does not have enough information to implement this feature. </p></li><li><p> The <a href="https://www.typescriptlang.org/docs/handbook/enums.html#const-enums"><code>const enum</code></a> feature in TypeScript defines a set of compile-time constants grouped under a type. Each enum value of that type is replaced by the corresponding constant at compile time. Since esbuild does not replicate TypeScript's type system, <code>const enum</code> declarations are compiled as <code>enum</code> declarations instead. </p></li></ul>
      <h4 id="tsconfig-json" data-h2="typescript" data-h3="typescript-caveats">
        <a class="permalink" href="#tsconfig-json">#</a>
        Only certain <code>tsconfig.json</code> fields are respected
      </h4>
      <p>During bundling, the path resolution algorithm in esbuild will consider the contents of the <code>tsconfig.json</code> file in the closest parent directory containing one and will modify its behavior accordingly. It is also possible to explicitly set the <code>tsconfig.json</code> path with the build API using esbuild's <a href="/api/#tsconfig"><code>tsconfig</code></a> setting and to explicitly pass in the contents of a <code>tsconfig.json</code> file with the transform API using esbuild's <a href="/api/#tsconfig-raw"><code>tsconfigRaw</code></a> setting. However, esbuild currently only inspects the following fields in <code>tsconfig.json</code> files:</p>
      <ul><li><a href="https://www.typescriptlang.org/tsconfig#baseUrl"><code>baseUrl</code></a></li><li><a href="https://www.typescriptlang.org/tsconfig#extends"><code>extends</code></a></li><li><a href="https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues"><code>importsNotUsedAsValues</code></a></li><li><a href="https://www.typescriptlang.org/tsconfig#jsxFactory"><code>jsxFactory</code></a></li><li><a href="https://www.typescriptlang.org/tsconfig#jsxFragmentFactory"><code>jsxFragmentFactory</code></a></li><li><a href="https://www.typescriptlang.org/tsconfig#paths"><code>paths</code></a></li><li><a href="https://www.typescriptlang.org/tsconfig#useDefineForClassFields"><code>useDefineForClassFields</code></a></li></ul>
      <p>All other fields will be ignored. Note that this includes TypeScript's <a href="https://www.typescriptlang.org/tsconfig#target"><code>target</code></a> setting. You'll need to set the compilation target using esbuild's own <a href="/api/#target"><code>target</code></a> setting instead. Also note that import path transformation requires <a href="/api/#bundle"><code>bundling</code></a> to be enabled, since path resolution only happens during bundling.</p>
      <h4 id="ts-vs-tsx" data-h2="typescript" data-h3="typescript-caveats">
        <a class="permalink" href="#ts-vs-tsx">#</a>
        You cannot use the <code>tsx</code> loader for <code>*.ts</code> files
      </h4>
      <p>The <code>tsx</code> loader is <em>not</em> a superset of the <code>ts</code> loader. They are two different partially-incompatible syntaxes. For example, the character sequence <code>&lt;a&gt;1&lt;/a&gt;/g</code> parses as <code>&lt;a&gt;(1 &lt; (/a&gt;/g))</code> with the <code>ts</code> loader and <code>(&lt;a&gt;1&lt;/a&gt;) / g</code> with the <code>tsx</code> loader. </p> <p>The most common issue this causes is not being able to use generic type parameters on arrow function expressions such as <code>&lt;T&gt;() =&gt; {}</code> with the <code>tsx</code> loader. This is intentional, and matches the behavior of the official TypeScript compiler. That space in the <code>tsx</code> grammar is reserved for JSX elements.</p>
      <h2 id="jsx">
        <a class="permalink" href="#jsx">#</a>
        JSX
      </h2>
      <p>Loader: <code>jsx</code> or <code>tsx</code></p>
      <p><a href="https://facebook.github.io/jsx/">JSX</a> is an XML-like syntax extension for JavaScript that was created for <a href="https://github.com/facebook/react">React</a>. It's intended to be converted into normal JavaScript by your build tool. Each XML element becomes a normal JavaScript function call. For example, the following JSX code:</p>
      <pre><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./button&#x27;</span>
<span class="hljs-keyword">let</span> button = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>
render(button)</pre>
      <p>Will be converted to the following JavaScript code:</p>
      <pre><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./button&quot;</span>;
<span class="hljs-keyword">let</span> button = React.createElement(Button, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Click me&quot;</span>);
render(button);</pre>
      <p>This loader is enabled by default for <code>.jsx</code> and <code>.tsx</code> files. Note that JSX syntax is not enabled in <code>.js</code> files by default. If you would like to enable that, you will need to configure it:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild app.js --bundle --loader:.js=jsx</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.js&#x27;</span>],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">loader</span>: { <span class="hljs-string">&#x27;.js&#x27;</span>: <span class="hljs-string">&#x27;jsx&#x27;</span> },
  <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.js&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.js&quot;</span>},
    Bundle:      <span class="hljs-literal">true</span>,
    Loader: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]api.Loader{
      <span class="hljs-string">&quot;.js&quot;</span>: api.LoaderJSX,
    },
    Write: <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <h3 id="auto-import-for-jsx" data-h2="jsx">
        <a class="permalink" href="#auto-import-for-jsx">#</a>
        Auto-import for JSX
      </h3>
      <p>Using JSX syntax usually requires you to manually import the JSX library you are using. For example, if you are using React, by default you will need to import React into each JSX file like this:</p>
      <pre><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>/&gt;</span></span>)</pre>
      <p>This is because the JSX transform turns JSX syntax into a call to <code>React.<wbr>createElement</code> but it does not itself import anything, so the <code>React</code> variable is not automatically present.</p>
      <p>If you would like to avoid having to manually <code>import</code> your JSX library into each file, you can use esbuild's <a href="/api/#inject">inject</a> feature to automatically import it into every file. This feature is a general-purpose polyfill mechanism that replaces references to global variables with an export from the injected file. In this case we can use it to replace references to the <code>React</code> variable with exports from the <code>react</code> package.</p>
      <p>First, create a file called <code>react-<wbr>shim.js</code> that re-exports everything from the <code>react</code> package in an export called <code>React</code>:</p>
      <pre><span class="hljs-comment">// react-shim.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">export</span> { React }</pre>
      <p>Then use esbuild's <a href="/api/#inject">inject feature</a> to inject this into each file:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild app.jsx --bundle --inject:./react-shim.js --outfile=out.js</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.jsx&#x27;</span>],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;./react-shim.js&#x27;</span>],
  <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.js&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.jsx&quot;</span>},
    Bundle:      <span class="hljs-literal">true</span>,
    Inject:      []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;./react-shim.js&quot;</span>},
    Outfile:     <span class="hljs-string">&quot;out.js&quot;</span>,
    Write:       <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <p>Since the inject feature is a general-purpose code injection mechanism, it can be used with any JSX transform library, not just with React.</p>
      <p><strong>Important:</strong> The <code>export</code> statement is required. Do not remove it. The inject feature injects an <code>import</code> statement to <code>react-shim.js</code> at the top of each file that looks like this:</p>
      <pre><span class="hljs-keyword">import</span> { <span class="hljs-comment">/* ... */</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./react-shim.js&#x27;</span></pre>
      <p>The set of imported names <code>/* ... */</code> is automatically generated from the set of unbound references in the file (i.e. <code>React</code>) that are equal to the name of an export of the injected file <code>react-shim.js</code>. If the injected file doesn't export anything, then the set of imported names stays empty and all unbound references all stay unbound. Code with unbound references to <code>React</code> will crash at run-time if there is no variable called <code>React</code> in the global scope. This is by design, and happens because of to how ECMAScript modules work. Imports in one module are local to that module and cannot be read from other modules unless they have been exported by that module and imported into the other module. Using <code>export</code> in <code>react-shim.js</code> with the local variable <code>React</code> allows it to be imported into and used by other modules.</p>
      <h3 id="using-jsx-without-react" data-h2="jsx">
        <a class="permalink" href="#using-jsx-without-react">#</a>
        Using JSX without React
      </h3>
      <p>If you're using JSX with a library other than React (such as <a href="https://preactjs.com/">Preact</a>), you'll likely need to configure the <a href="/api/#jsx-factory">JSX factory</a> and <a href="/api/#jsx-fragment">JSX fragment</a> settings since they default to <code>React<wbr>.createElement</code> and <code>React<wbr>.Fragment</code> respectively:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild app.jsx --jsx-factory=h --jsx-fragment=Fragment</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.jsx&#x27;</span>],
  <span class="hljs-attr">jsxFactory</span>: <span class="hljs-string">&#x27;h&#x27;</span>,
  <span class="hljs-attr">jsxFragment</span>: <span class="hljs-string">&#x27;Fragment&#x27;</span>,
  <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.js&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.jsx&quot;</span>},
    JSXFactory:  <span class="hljs-string">&quot;h&quot;</span>,
    JSXFragment: <span class="hljs-string">&quot;Fragment&quot;</span>,
    Write:       <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <p>Alternatively, if you are using TypeScript, you can just configure JSX for TypeScript by adding this to your <code>tsconfig.json</code> file and esbuild should pick it up automatically without needing to be configured:</p>
      <pre>{
  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-attr">&quot;jsxFactory&quot;</span>: <span class="hljs-string">&quot;h&quot;</span>,
    <span class="hljs-attr">&quot;jsxFragmentFactory&quot;</span>: <span class="hljs-string">&quot;Fragment&quot;</span>
  }
}</pre>
      <p>You will also have to add <code>import <wbr>{h, <wbr>Fragment} <wbr>from <wbr>'preact'</code> in files containing JSX syntax unless you use auto-importing as described above.</p>
      <h2 id="json">
        <a class="permalink" href="#json">#</a>
        JSON
      </h2>
      <div>Loader: <code>json</code></div>
      <p>This loader is enabled by default for <code>.json</code> files. It parses the JSON file into a JavaScript object at build time and exports the object as the default export. Using it looks something like this:</p>
      <pre><span class="hljs-keyword">import</span> object <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.json&#x27;</span>
<span class="hljs-built_in">console</span>.log(object)</pre>
      <p>In addition to the default export, there are also named exports for each top-level property in the JSON object. Importing a named export directly means esbuild can automatically remove unused parts of the JSON file from the bundle, leaving only the named exports that you actually used. For example, this code will only include the <code>version</code> field when bundled:</p>
      <pre><span class="hljs-keyword">import</span> { version } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./package.json&#x27;</span>
<span class="hljs-built_in">console</span>.log(version)</pre>
      <h2 id="css">
        <a class="permalink" href="#css">#</a>
        CSS
      </h2>
      <p>Loader: <code>css</code></p>
      <div class="warning">The CSS content type is new and is still a work in progress. There is also a known <a href="https://github.com/evanw/esbuild/issues/465">ordering issue</a> with importing CSS files from JavaScript files. You can follow <a href="https://github.com/evanw/esbuild/issues/20">the tracking issue</a> for updates about this feature.</div>
      <p>This loader is enabled by default for <code>.css</code> files. It loads the file as CSS syntax. CSS is a first-class content type in esbuild, which means esbuild can bundle CSS files directly without needing to import your CSS from JavaScript code:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild --bundle app.css --outfile=out.css</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.css&#x27;</span>],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.css&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.css&quot;</span>},
    Bundle:      <span class="hljs-literal">true</span>,
    Outfile:     <span class="hljs-string">&quot;out.css&quot;</span>,
    Write:       <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <p>You can <code>@import</code> other CSS files and reference image and font files with <code>url()</code> and esbuild will bundle everything together. Note that you will have to configure a loader for image and font files, since esbuild doesn't have any pre-configured. Usually this is either the <a href="#data-url">data URL</a> loader or the <a href="#external-file">external file</a> loader.</p>
      <p>You can also import CSS from JavaScript. When you do this, esbuild will gather all CSS files referenced from a given entry point and bundle it into a sibling CSS output file next to the JavaScript output file for that JavaScript entry point. So if esbuild generates <code>app.js</code> it would also generate <code>app.css</code> containing all CSS files referenced by <code>app.js</code>. Here's an example of importing a CSS file from JavaScript:</p>
      <pre><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./button.css&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> Button = <span class="hljs-function">(<span class="hljs-params">{ text }</span>) =&gt;</span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>{text}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></pre>
      <p>Note that esbuild doesn't yet support CSS modules, so the set of export names from a CSS file is currently always empty. Supporting a basic form of CSS modules is on the roadmap.</p>
      <h2 id="text">
        <a class="permalink" href="#text">#</a>
        Text
      </h2>
      <p>Loader: <code>text</code></p>
      <p>This loader is enabled by default for <code>.txt</code> files. It loads the file as a string at build time and exports the string as the default export. Using it looks something like this:</p>
      <pre><span class="hljs-keyword">import</span> string <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.txt&#x27;</span>
<span class="hljs-built_in">console</span>.log(string)</pre>
      <h2 id="binary">
        <a class="permalink" href="#binary">#</a>
        Binary
      </h2>
      <p>Loader: <code>binary</code></p>
      <p>This loader will load the file as a binary buffer at build time and embed it into the bundle using Base64 encoding. The original bytes of the file are decoded from Base64 at run time and exported as a <code>Uint8Array</code> using the default export. Using it looks like this:</p>
      <pre><span class="hljs-keyword">import</span> uint8array <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.data&#x27;</span>
<span class="hljs-built_in">console</span>.log(uint8array)</pre>
      <p>If you need an <code>ArrayBuffer</code> instead, you can just access <code>uint8array<wbr>.buffer</code>. Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild app.js --bundle --loader:.data=binary</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.js&#x27;</span>],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">loader</span>: { <span class="hljs-string">&#x27;.data&#x27;</span>: <span class="hljs-string">&#x27;binary&#x27;</span> },
  <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.js&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.js&quot;</span>},
    Bundle:      <span class="hljs-literal">true</span>,
    Loader: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]api.Loader{
      <span class="hljs-string">&quot;.data&quot;</span>: api.LoaderBinary,
    },
    Write: <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <h2 id="base64">
        <a class="permalink" href="#base64">#</a>
        Base64
      </h2>
      <p>Loader: <code>base64</code></p>
      <p>This loader will load the file as a binary buffer at build time and embed it into the bundle as a string using Base64 encoding. This string is exported using the default export. Using it looks like this:</p>
      <pre><span class="hljs-keyword">import</span> base64string <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.data&#x27;</span>
<span class="hljs-built_in">console</span>.log(base64string)</pre>
      <p>Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild app.js --bundle --loader:.data=base64</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.js&#x27;</span>],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">loader</span>: { <span class="hljs-string">&#x27;.data&#x27;</span>: <span class="hljs-string">&#x27;base64&#x27;</span> },
  <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.js&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.js&quot;</span>},
    Bundle:      <span class="hljs-literal">true</span>,
    Loader: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]api.Loader{
      <span class="hljs-string">&quot;.data&quot;</span>: api.LoaderBase64,
    },
    Write: <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <p>If you intend to turn this into a <code>Uint8Array</code> or an <code>ArrayBuffer</code>, you should use the <code>binary</code> loader instead. It uses an optimized Base64-to-binary converter that is faster than the usual <code>atob</code> conversion process.</p>
      <h2 id="data-url">
        <a class="permalink" href="#data-url">#</a>
        Data URL
      </h2>
      <p>Loader: <code>dataurl</code></p>
      <p>This loader will load the file as a binary buffer at build time and embed it into the bundle as a Base64-encoded data URL. This string is exported using the default export. Using it looks like this:</p>
      <pre><span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.png&#x27;</span>
<span class="hljs-keyword">let</span> image = <span class="hljs-keyword">new</span> Image
image.src = url
<span class="hljs-built_in">document</span>.body.appendChild(image)</pre>
      <p>The data URL includes a best guess at the MIME type based on the file extension and/or the file contents, and will look something like this:</p>
      <pre>data:image/png;base64,iVBORw0KGgo=</pre>
      <p>Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild app.js --bundle --loader:.png=dataurl</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.js&#x27;</span>],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">loader</span>: { <span class="hljs-string">&#x27;.png&#x27;</span>: <span class="hljs-string">&#x27;dataurl&#x27;</span> },
  <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.js&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.js&quot;</span>},
    Bundle:      <span class="hljs-literal">true</span>,
    Loader: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]api.Loader{
      <span class="hljs-string">&quot;.png&quot;</span>: api.LoaderDataURL,
    },
    Write: <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <h2 id="external-file">
        <a class="permalink" href="#external-file">#</a>
        External file
      </h2>
      <p>Loader: <code>file</code></p>
      <p>This loader will copy the file to the output directory and embed the file name into the bundle as a string. This string is exported using the default export. Using it looks like this:</p>
      <pre><span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.png&#x27;</span>
<span class="hljs-keyword">let</span> image = <span class="hljs-keyword">new</span> Image
image.src = url
<span class="hljs-built_in">document</span>.body.appendChild(image)</pre>
      <p>Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:</p>
      <div class="switcher">
        <a href="javascript:void 0" class="cli3">CLI</a>
        <a href="javascript:void 0" class="js3">JS</a>
        <a href="javascript:void 0" class="go3">Go</a>
      </div>
      <pre class="switchable cli3">esbuild app.js --bundle --loader:.png=file --outdir=out</pre>
      <pre class="switchable js3"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).buildSync({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.js&#x27;</span>],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">loader</span>: { <span class="hljs-string">&#x27;.png&#x27;</span>: <span class="hljs-string">&#x27;file&#x27;</span> },
  <span class="hljs-attr">outdir</span>: <span class="hljs-string">&#x27;out&#x27;</span>,
})</pre>
      <pre class="switchable go3"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/evanw/esbuild/pkg/api&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  result := api.Build(api.BuildOptions{
    EntryPoints: []<span class="hljs-keyword">string</span>{<span class="hljs-string">&quot;app.js&quot;</span>},
    Bundle:      <span class="hljs-literal">true</span>,
    Loader: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]api.Loader{
      <span class="hljs-string">&quot;.png&quot;</span>: api.LoaderFile,
    },
    Outdir: <span class="hljs-string">&quot;out&quot;</span>,
    Write:  <span class="hljs-literal">true</span>,
  })

  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
    os.Exit(<span class="hljs-number">1</span>)
  }
}</pre>
      <p>By default the exported string is just the file name. If you would like to prepend a base path to the exported string, this can be done with the <a href="/api/#public-path">public path</a> API option.</p>
    </main>
  </body>
</html>
